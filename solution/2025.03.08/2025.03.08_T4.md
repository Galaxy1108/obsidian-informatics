[[problem(1).pdf#page=6|problem]]

**此题原题解有误** 

首先，对于每个数字 $0$，我们将其改变为 $-1$，那么问题就转换成了最大矩阵边框和

这道题需要使用前缀和优化，我们约定以下表达方式

首先
- 使用 $sn_{i,j}$ 来表示 矩阵第 $i$ 行 $j$ 列的元素
基于这个，我们
- 使用 $is_{i,j}$ 来表示 $\displaystyle\sum^{j}_{k=1}sn_{i,k}$ 即 矩阵第 $i$ 行的前 $j$ 个元素和
- 使用 $js_{i,j}$ 来表示 $\displaystyle\sum^{i}_{k=1}sn_{k,j}$ 即 矩阵第 $j$ 列的前 $i$ 个元素和
那么，设这个矩形的上界为 $i_1$，下界为 $j_1$，左界为 $i_2$，右界为 $j_2$
有我们要求的边框和为 
$$
(is_{i_1,j_2}-is_{i_1,i_2-1})+(is_{j_1,j_2-1}-is_{j_1,i_2})+(js_{j_1-1,i_2}-js_{i_1,i_2})+(js_{j_1-1,j_2}-js_{i_1,j_2})
$$
我们分离 $i_2$ 和 $j_2$ 对边框和的贡献，那么有
- $i_2$ 对边框和的贡献为 $js_{j_1-1,i_2}-js_{i_1,i_2}-is_{i_1,j_2-1}-is_{j_1,i_2}$  
- $j_2$ 对边框和的贡献为 $is_{i_1,j_2}+is_{i_1,j_2-1}+js_{j_1-1,j_2}-js_{i_1,j_2}$ 
我们 $O(n^2)$ 枚举 $i_1$ 与 $j_1$，然后使用双指针动态 $O(n)$ 枚举贡献最大的 $i_2$ 与 $j_2$，即可 $O(n^3)$ 求出解

code:
```cpp
#include <stdio.h>
const int nmax = 200;

int t, n, m;
int sc[nmax + 18][nmax + 18]; //js_{i,j}
int sr[nmax + 18][nmax + 18]; //is_{i,j}
int a[nmax + 18][nmax + 18], ans, w;
int u[nmax + 18], v[nmax + 18];

void update(int a, int k){
    if (a > ans){
	    ans = a, w = k;
    }else if (a == ans){
	    w += k;
	}
}

int main()
{
    freopen("Rider.in", "r", stdin);
    freopen("Rider.out", "w", stdout);
    scanf("%d", &t);u[0] = 1 << 31;
    while (t--){
		scanf("%d%d", &n, &m);
		ans = -n * m;
		for (int i = 1; i <= n; ++i){
		    for (int j = 1; j <= m; ++j){
				scanf("%d", a[i] + j);
				update(a[i][j] ? a[i][j] : --a[i][j], 1); //计算单点矩阵
			}
		}
		for (int i = 1; i <= n; ++i){
		    for (int j = 1; j <= m; ++j){
				sc[i][j] = sc[i][j - 1] + a[i][j], sr[i][j] = sr[i - 1][j] + a[i][j]; //计算is与js
			}
		}
		for (int j = 1; j <= n; ++j){
		    for (int i = j + 1; i <= n; ++i){
				for (int k = 1; k <= m; update(sr[i][k] - sr[j - 1][k++], 1)){ //计算单行的矩阵
				    u[k] = sr[i - 1][k] - sr[j][k] - sc[i][k - 1] - sc[j][k - 1],v[k] = sc[i][k] + sc[j][k] + sr[i - 1][k] - sr[j][k];
			//分别计算 i_2 与 j_2 的贡献，形象解释附下
			/*
			u_k->
				.......(k)
				        .
				--------.(j)
						+(j+1)
						+
						+(i-1)
				--------.(i)
					   
			v_k->
				........(k)
				         .
				++++++++++(j)
					     +(j+1)
						 +
						 +(i-1)
				++++++++++(i)
			*/

			//双指针动态维护
			for (int k = 0, l = 2, s = 1; l <= m; update(u[k] + v[l++], s)){
			    if (u[l - 1] > u[k]){
                    k = l - 1, s = 1;
                }else if(u[l - 1] == u[k]){
	                ++s;
	            }
	            
	        } 
	    }
	    } 
		}
		for (int i = 1; i <= m; ++i){
		    for (int j = i + 1; j <= m; ++j){
				for (int k = 1; k <= n; ++k){
				    update(sc[k][j] - sc[k][i - 1], 1); //计算单列矩阵
			    }
			}
		}
		printf("%d %d\n", ans, w);
    }
    return 0;
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	cout<<"Hello world!";
}
```