判断数字 $x$ 是否可行

设有 $a$ 个数小于 $x$，$b$ 个数等于 $x$，$c$ 个数大于 $x$

由题意，显然有

1.  $a+b\ge c$
2.  $a \le b+c$

然后思考如何处理

有显然的贪心，当 $l_{i,2} \le x \le r_{i,2}$，此时应取 $x$，放 $r_{i,1}$ 个



由上面的不等式，有 $c>a-b$，$c \leq a+b$

即 $c$ 在 $a-b+1$ 至 $a+b$ 区间内

对于 $a$，我们预处理出 $a_l$， $a_r$

那么有 $c$ 在 $a_l-b+1$ 至 $a_r+b$ 区间内

同时，我们需要处理出 $c_l$，$c_r$ 来判断 $x$ 是否可行



如何求得 $b_{max}$ 与 $a_l$，$a_r$？

对于 $l_{i,2}$，$r_{i,2}$，贡献如下：

- 对于 $l_{i,2}\le x\le r_{i,2}$，对 $b_{max}$ 贡献 $r_{i,1}$
- 对于 $x<l_{i,2}$，对 $c_l$ 贡献 $l_{i,1}$，对 $c_r$ 贡献 $r_{i,1}$
- 对于 $x>r_{i,2}$，对 $a_l$ 贡献 $l_{i,1}$，对 $ a_r$ 贡献 $r_{i,1}$



使用差分+前缀和统计每个 $x$ 下的 $a_l$，$a_r$，$b_{max}$，$c_l$，$c_r$ 即可



最终的判断及判断是否有

$\max{(a_l-b_{max}+1,c_l)} \leq \min{(a_r+b_{max},c_r)}$

因为这为 $c$ 的取值范围



代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll l1[400005], r1[400005], l2[400005], r2[400005];
ll al[400005], ar[400005], bn[400005], cl[400005], cr[400005];
ll xs[400005], tops;
ll cn[400005];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    ll c, T;
    cin >> c >> T;
    while(T--){
        ll n;
        cin >> n;
        fill(al, al + tops + 1, 0);
        fill(ar, ar + tops + 1, 0);
        fill(bn, bn + tops + 1, 0);
        fill(cl, cl + tops + 1, 0);
        fill(cr, cr + tops + 1, 0);
        fill(cn, cn + tops + 1, 0);
        tops = 0;
        for (ll i = 1; i <= n;i++){
            cin >> l1[i] >> r1[i] >> l2[i] >> r2[i];
            xs[++tops] = l2[i], xs[++tops] = r2[i] + 1;
        }
        sort(xs + 1, xs + tops + 1);
        tops = unique(xs + 1, xs + tops + 1) - xs - 1;
        for (ll i = 1; i <= n;i++){
            ll l = lower_bound(xs + 1, xs + tops + 1, l2[i]) - xs;
            ll r = lower_bound(xs + 1, xs + tops + 1, r2[i] + 1) - xs;
            bn[l] += r1[i], bn[r] -= r1[i];
            al[r] += l1[i];
            ar[r] += r1[i];
            cl[1] += l1[i], cl[l] -= l1[i];
            cr[1] += r1[i], cr[l] -= r1[i];
            cn[l]++, cn[r]--;
        }
        long long anss = 0;
        for (ll i = 1; i < tops;i++){
            bn[i] += bn[i - 1];
            al[i] += al[i - 1], ar[i] += ar[i - 1];
            cl[i] += cl[i - 1], cr[i] += cr[i - 1];
            cn[i] += cn[i - 1];
            if(!cn[i] || max(al[i] - bn[i] + 1, cl[i]) > min(ar[i] + bn[i], cr[i])) {
                continue;
            }
            anss += xs[i + 1] - xs[i];
        }
        cout << anss << '\n';
    }
}
```



