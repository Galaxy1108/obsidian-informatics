---
熟练度:
  - t3
---
## 基础

记忆化搜索是在 [深度优先搜索] 上的改进
接下来以洛谷[P1216](https://www.luogu.com.cn/problem/P1216)为例，来讲解一下

> [!node]- 题面
> # [USACO1.5] [IOI1994]数字三角形 Number Triangles
>
>## 题目描述
>
>观察下面的数字金字塔。
>
>
>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。
>
>![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)
>
>在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。
>
>## 输入格式
>
>第一个行一个正整数 $r$ ,表示行的数目。
>
>后面每行为这个数字金字塔特定行包含的整数。
>
>## 输出格式
>
>单独的一行,包含那个可能得到的最大的和。
>
>## 样例 #1
>
>### 样例输入 #1
>
>```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
>```
>### 样例输出 #1
>
>```
>30
>```
>
>## 提示
>
>【数据范围】  
>对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。
>
>题目翻译来自NOCOW。
>
>USACO Training Section 1.5
>
>IOI1994 Day1T1


### 暴力-DFS

这道题暴力不难，核心代码也就几行

> [!warning] 注意
> 这道题不能用贪心

```cpp
int dfs(int x,int y){ 
	if(x==n){ 
		return a[x][y]; 
	} 
	return max(dfs(x+1,y),dfs(x+1,y+1)) + a[x][y]; 
}
```

相信这也不难，可以得[55分](https://www.luogu.com.cn/record/114266032)

### 正解-记忆化搜索

当然，我们可以看出，上面这个代码有很多点是重复计算的，比如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在这张图中，`dfs(3,2)`被执行了多次，一次是在计算`dfs(2,1)`时，一次是在计算`dfs(2,2)`时，从这里可以看出，如果我们记录一下函数的结果，`dfs(2,2)`就可以直接调用结果，从而减少时间复杂度。

核心代码依然很简单：

```cpp
int dfs(int x,int y){ 
	if(g[x][y]!=-1){ 
		return g[x][y];
	} if(x==n){ 
		return g[x][y]=a[x][y];
	} 
	return g[x][y]=max(dfs(x+1,y),dfs(x+1,y+1)) + a[x][y]; 
}
```

当然，要加上记录结果的数组

```cpp
int g[1001][1001];
```

这样，我们就得到了[满分](https://www.luogu.com.cn/record/114267321)
