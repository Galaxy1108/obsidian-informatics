---
熟练度:
  - t2
---
## 基础

DP的基础其实是记忆化搜索
接下来以洛谷[P1216](https://www.luogu.com.cn/problem/P1216)为例，来讲解一下

> [!node]- 题面
> # [USACO1.5] [IOI1994]数字三角形 Number Triangles
>
>## 题目描述
>
>观察下面的数字金字塔。
>
>
>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。
>
>![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)
>
>在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。
>
>## 输入格式
>
>第一个行一个正整数 $r$ ,表示行的数目。
>
>后面每行为这个数字金字塔特定行包含的整数。
>
>## 输出格式
>
>单独的一行,包含那个可能得到的最大的和。
>
>## 样例 #1
>
>### 样例输入 #1
>
>```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
>```
>### 样例输出 #1
>
>```
>30
>```
>
>## 提示
>
>【数据范围】  
>对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。
>
>题目翻译来自NOCOW。
>
>USACO Training Section 1.5
>
>IOI1994 Day1T1


### 暴力-DFS

这道题暴力不难，核心代码也就几行

> [!warning] 注意
> 这道题不能用贪心

```cpp
int dfs(int x,int y){ 
	if(x==n){ 
		return a[x][y]; 
	} 
	return max(dfs(x+1,y),dfs(x+1,y+1)) + a[x][y]; 
}
```

相信这也不难，可以得[55分](https://www.luogu.com.cn/record/114266032)

<iframe src="https://www.luogu.com.cn/record/114266032"></iframe>


### 正解-记忆化搜索

当然，我们可以看出，上面这个代码有很多点是重复计算的，比如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在这张图中，`dfs(3,2)`被执行了多次，一次是在计算`dfs(2,1)`时，一次是在计算`dfs(2,2)`时，从这里可以看出，如果我们记录一下函数的结果，`dfs(2,2)`就可以直接调用结果，从而减少时间复杂度。

核心代码依然很简单：

```cpp
int dfs(int x,int y){ 
	if(g[x][y]!=-1){ 
		return g[x][y];
	} if(x==n){ 
		return g[x][y]=a[x][y];
	} 
	return g[x][y]=max(dfs(x+1,y),dfs(x+1,y+1)) + a[x][y]; 
}
```

当然，要加上记录结果的数组

```cpp
int g[1001][1001];
```

这样，我们就得到了[满分](https://www.luogu.com.cn/record/114267321)

<iframe src="https://www.luogu.com.cn/record/114267321"></iframe> 

### 不满足于此 - DP

我们需要知道，我们在递归时要占用栈空间，这既不利于时间复杂度，也不利于空间复杂度，这时DP就派上用场了。

在之前的代码中，我们是从顶端递归到底端，这是不利于我们将递归转换成DP的。但是我们只要倒过来想，从底端递归到顶端，就很简单了。

这类似于我们递归的回溯过程，这时，我们对于每个点，我们只需要知道这个对应这个点的第`x+1,y`个点的最大权值和和`x+1,y+1`个点的最大权值和的最大值，就是这个点的最大权值和，我们再用类似记忆化搜索的方法记录下来，就得到了结果。

用状态转移方程来表示就是

$$
g(x,y)\ =\ max(g(x\ +\ 1,y),g(x\ +\ 1,y\ +\ 1))\ +\ a_{x,y}
$$

代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1001][1001],n;
int g[1001][1001];

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            cin>>a[i][j];
        }
    }
    for(int i=n-1;i>0;i--){
        for(int j=0;j<i;j++){
            g[i-1][j]+=max(g[i][j],g[i][j+1])+a[i][j];
        }
    }
    cout<<a[0][0];
}
```

可以看出，在这个代码中，数组 $a$ 是没什么用的，那么我们可以吧 $a$ 数组和 $g$ 数组合并，就有了一下代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1001][1001],n;

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            cin>>a[i][j];
        }
    }
    for(int i=n-1;i>0;i--){
        for(int j=0;j<i;j++){
            a[i-1][j]+=max(a[i][j],a[i][j+1]);
        }
    }
    cout<<a[0][0];
}
```

这样，我们就得到了[更优的结果](https://www.luogu.com.cn/record/114274306)

<iframe src="https://www.luogu.com.cn/record/114274306"></iframe>

