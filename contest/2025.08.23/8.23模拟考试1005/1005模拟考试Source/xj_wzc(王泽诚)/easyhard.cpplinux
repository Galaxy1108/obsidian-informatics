#include <bits/stdc++.h>
#define R(i, a, b) for (auto i = (a); i < (b); ++i)
#define L(i, a, b) for (auto i = (b) - 1; i >= (a); --i)
#define N(a) int((a).size())
#define V(a) (a).begin(), (a).end()
#define P make_pair
#define spc << ' '
#define ntr << '\n'
#define X(a) cerr << #a << " = " << a
#define T() cerr << "TIME = " << double(clock() - T0) / CLOCKS_PER_SEC
using namespace std;
using i64 = long long;
clock_t T0 = clock();
template<typename tp>
ostream &operator<<(ostream &ost, const pair<tp, tp> &a) {
	for (tp i = a.first; i != a.second; ++i) ost << setw(3) << *i;
	return ost;
}
constexpr int xN = 3000 + 7;
int N, M, mod;
int f[xN][2], g[xN][2];
int main() {
	freopen("easyhard.in", "r", stdin);
	freopen("easyhard.out", "w", stdout);
	cerr << fixed << setprecision(3);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> N >> M >> mod;
	R(i, 0, N + 1) f[i][i == 0] = 1;
	R(t, 0, M) {
		R(i, 0, N + 1) R(j, 0, 2) {
			if (i - 1 >= 0) {
				(g[i - 1][j or i == 1] += f[i][j]) %= mod;
				(g[i][j or i == 1] += f[i][j]) %= mod;
			}
			if (i + 1 <= N) {
				(g[i + 1][j] += f[i][j]) %= mod;
				(g[i][j] += f[i][j]) %= mod;
			}
		}
		R(i, 0, N + 1) R(j, 0, 2) {
			f[i][j] = g[i][j];
			g[i][j] = 0;
		}
	}
	int res = 0;
	R(i, 0, N + 1) (res += f[i][1]) %= mod;
	cout << res ntr;
}
