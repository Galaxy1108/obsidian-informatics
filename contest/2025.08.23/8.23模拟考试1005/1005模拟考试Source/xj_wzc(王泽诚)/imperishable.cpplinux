#include <bits/stdc++.h>
#define R(i, a, b) for (auto i = (a); i < (b); ++i)
#define L(i, a, b) for (auto i = (b) - 1; i >= (a); --i)
#define N(a) int((a).size())
#define V(a) (a).begin(), (a).end()
#define P make_pair
#define spc << ' '
#define ntr << '\n'
#define X(a) cerr << #a << " = " << a
#define T() cerr << "TIME = " << double(clock() - T0) / CLOCKS_PER_SEC
using namespace std;
using i64 = long long;
clock_t T0 = clock();
template<typename tp>
ostream &operator<<(ostream &ost, const pair<tp, tp> &a) {
	for (tp i = a.first; i != a.second; ++i) ost << setw(3) << *i;
	return ost;
}
constexpr int mod = 998244353;
int add(int x, int y) {
	x += y;
	return x >= mod ? x - mod : x;
}
int case_id;
constexpr int xN = 200000 + 7, xk = 20;
int w[xN], sw;
int N, M, a[xN];
int level(int x) {
	return 32 - __builtin_clz(x) - 1;
}
constexpr int xp = 400000 + 7;
int p = 1, ls[xp], rs[xp];
i64 f[xp][xk];
int mx[xp], mi[xp][xk], g[xp][xk];
int rt;
void pushup(int u) {
	R(k, 0, xk) {
		g[u][k] = add(g[ls[u]][k], g[rs[u]][k]);
		f[u][k] = f[ls[u]][k] + f[rs[u]][k];
		mi[u][k] = min<i64>(mi[ls[u]][k] + f[rs[u]][k], mi[rs[u]][k]);
	}
	mx[u] = max(mx[ls[u]], mx[rs[u]]);
}
void assign(int u, int i) {
	int l = level(a[i]);
	R(k, 0, xk) {
		f[u][k] = g[u][k] = 0;
		mi[u][k] = 2 << k;
	}
	mi[u][l] = a[i];
	R(k, l + 1, xk) {
		f[u][k] = a[i];
		g[u][k] = w[i];
	}
	mx[u] = a[i];
}
void build(int &u, int l = 0, int r = N) {
	u = p++;
	assert(u < xp);
	if (r - l == 1) return assign(u, l);
	int mid = (l + r) / 2;
	build(ls[u], l, mid);
	build(rs[u], mid, r);
	pushup(u);
}
void fix(int u, int i, int l = 0, int r = N) {
	if (r - l == 1) return assign(u, i);
	int mid = (l + r) / 2;
	if (i < mid) fix(ls[u], i, l, mid);
	else fix(rs[u], i, mid, r);
	pushup(u);
}
i64 X;
int res_calc;
void calc(int u, int l = 0, int r = N) {
	if (!X) return;
	int k = min(level(X), 17);
	if (X >= f[u][k] and X < mi[u][k]) {
		X -= f[u][k];
		res_calc = add(res_calc, g[u][k]);
		return;
	}
	if (X >= f[u][k + 1]) {
		X -= f[u][k + 1];
		res_calc = add(res_calc, g[u][k + 1]);
		return;
	}
	int mid = (l + r) / 2;
	calc(rs[u], mid, r);
	calc(ls[u], l, mid);
}
// int recalc1() {
// 	int cur = accumulate(a, a + N, 0) - *max_element(a, a + N);
// 	int res = 0;
// 	L(i, 0, N) if (cur >= a[i]) cur -= a[i]; else res = add(res, w[i]);
// 	return res;
// }
int recalc() {
	X = f[rt][xk - 1] - mx[rt];
	res_calc = 0;
	calc(rt);
	return add(sw, mod - res_calc);
}
int main() {
	freopen("imperishable.in", "r", stdin);
	freopen("imperishable.out", "w", stdout);
	cerr << fixed << setprecision(3);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> case_id >> N;
	w[0] = 2;
	R(i, 1, N) w[i] = add(w[i - 1], w[i - 1]);
	sw = accumulate(w, w + N, 0, add);
	R(i, 0, N) cin >> a[i];
	build(rt);
	cout << recalc() ntr;
	cin >> M;
	R(t, 0, M) {
		int i, x;
		cin >> i >> x, --i;
		a[i] = x;
		fix(rt, i);
		cout << recalc() ntr;
	}
}
