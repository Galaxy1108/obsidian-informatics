#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NR=2e5+5;
const int mod=998244353;
int n,q;
int a[NR];
struct segtree{
	int mx,sum;
}tree[NR<<2];
void pushup(int id){
	tree[id].mx=max(tree[id<<1].mx,tree[id<<1|1].mx);
	tree[id].sum=tree[id<<1].sum+tree[id<<1|1].sum;
}
void build(int id,int l,int r){
	if(l==r){
		tree[id].mx=tree[id].sum=a[l];
		return;
	}
	int mid=l+r>>1;
	build(id<<1,l,mid); build(id<<1|1,mid+1,r);
	pushup(id); 
}
void modify(int id,int l,int r,int x,int k){
	if(l==r&&l==x){
		tree[id].mx=tree[id].sum=k;
		//cout << id << " " << tree[id].mx << " " << tree[id].sum <<  " " << k << endl; 
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) modify(id<<1,l,mid,x,k);
	else modify(id<<1|1,mid+1,r,x,k);
	pushup(id);
}
int querysum(int id,int l,int r,int p,int q){
	if(l>q||r<p) return 0;
	if(l>=p&&r<=q) return tree[id].sum;
	int mid=l+r>>1;
	return querysum(id<<1,l,mid,p,q)+querysum(id<<1|1,mid+1,r,p,q);
}
int querymax(int id,int l,int r,int p,int q){
	if(l>q||r<p) return 0;
	if(l>=p&&r<=q) return tree[id].mx;
	int mid=l+r>>1;
	return max(querymax(id<<1,l,mid,p,q),querymax(id<<1|1,mid+1,r,p,q));
}
bool check(int mid){
	if(querysum(1,1,n,1,mid)>=querymax(1,1,n,mid+1,n)) return 1;
	else return 0;
}
bool checkcheck(int mid,int now,int wow,int l){
	if(wow-querysum(1,1,n,mid+1,l-1)>=now) return 1;
	else return 0;
}
int pre2[NR],pow2[NR];
int binarySearch(){
	int l=1,r=n;
	while(l<r){
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	//cout << querysum(1,1,n,1,l) << " " << querymax(1,1,n,l+1,n) << endl;
	int ans=pre2[l];
	int now=querymax(1,1,n,l+1,n),wow=querysum(1,1,n,1,l);
	while(!(9>10)){
		int L=0,R=l-1;
		while(L<R){
			int mid=L+R>>1;
			if(checkcheck(mid,now,wow,l)) R=mid;
			else L=mid+1;
		}
		//cout << L <<" "<<l<< '\n';
		if(L<l-1) wow-=querysum(1,1,n,L+1,l-1),ans-=(pre2[l-1]-pre2[L]),l=L;
		else break;
	}
	return ans;
}
signed main(){
	//freopen("imperishable.in","r",stdin);
	//freopen("imperishable.out","w",stdout);
	cin >> n;
	cin >> n;
	pre2[1]=2; pow2[1]=2;
	for(int i=2;i<=n;i++){
		pow2[i]=pow2[i-1]*2%mod;
		pre2[i]=(pre2[i-1]+pow2[i])%mod;
		//cout << pow2[i] << " " <<pre2[i] << endl;
	}
	for(int i=1;i<=n;i++) cin >> a[i];
	build(1,1,n);
	cout << binarySearch() << '\n';
	cin >> q;
	while(q--){
		int x,y;
		cin >> x >> y;
		a[x]=y;
		modify(1,1,n,x,y);
		cout << binarySearch() << '\n';
	}
	return 0;
}
/*
0
4
4 1 2 3 
2
1 1 
1 2 
*/ 
