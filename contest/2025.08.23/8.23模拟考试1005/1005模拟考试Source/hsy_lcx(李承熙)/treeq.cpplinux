#include<bits/stdc++.h>
using namespace std;
inline int qread()
{
	int a=0;char ch=getchar();
	while(ch>'9'||ch<'0'){ch=getchar();}
	while(ch>='0'&&ch<='9'){(a*=10)+=(ch^48);ch=getchar();}
	return a;
}
int n,u,w,head[1000010],tot,siz[1000010],vis[1000010];
long long que[5010][5010][2],f[1000010],ans;
struct qxx
{
	int nex,t,v;
}e[2000010];
inline void adde(int x,int y,int w)
{
	e[++tot].t=y;
	e[tot].nex=head[x];
	head[x]=tot;
	e[tot].v=w;
	return ;
}
inline void dfss(int rt,int da,long long v,int pos)
{
	vis[rt]=pos;
	if(!que[rt][0][0])
	{
		que[rt][++que[rt][0][0]][0]=v;
		que[rt][que[rt][0][0]][1]=pos;
	}
	else if(que[rt][1][0]<v)
	{
		que[rt][0][0]=1;
		que[rt][1][0]=v;
		que[rt][1][1]=pos;
	}
	else if(que[rt][1][0]==v)
	{
		que[rt][++que[rt][0][0]][0]=v;
		que[rt][que[rt][0][0]][1]=pos;
	}
	for(int i=head[rt];i;i=e[i].nex)
	{
		if(e[i].t==da)continue;
		dfss(e[i].t,rt,v,pos);
	}
	return ;
}
inline void dfs(int rt,int da)
{
	long long v=0;
	siz[rt]=1;
	for(int i=head[rt];i;i=e[i].nex)
	{
		if(e[i].t==da)
		{
			v=e[i].v;
			continue;
		}
		dfs(e[i].t,rt);
		siz[rt]+=siz[e[i].t];
	}
	dfss(rt,da,v*(n-siz[rt]),rt);
	v*=siz[rt];
	for(int i=1;i<=n;++i)
	{
		if(vis[i]!=rt)
		{
			if(!que[i][0][0])
			{
				que[i][++que[i][0][0]][0]=v;
				que[i][que[i][0][0]][1]=rt;
			}
			else if(que[i][1][0]<v)
			{
				que[i][0][0]=1;
				que[i][1][0]=v;
				que[i][1][1]=rt;
			}
			else if(que[i][1][0]==v)
			{
				que[i][++que[i][0][0]][0]=v;
				que[i][que[i][0][0]][1]=rt;
			}
		}
	}
	return ;
}
int main()
{
	freopen("treeq.in","r",stdin);
	freopen("treeq.out","w",stdout);
	n=qread();
	for(int i=2;i<=n;++i)
	{
		u=qread();
		w=qread();
		adde(u,i,w);
		adde(i,u,w);
	}
	if(n<=5000)
	{
		dfs(1,0);
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=que[i][0][0];++j)
			{
				++f[que[i][j][1]];
			} 
		}
		for(int i=1;i<=n;++i)ans^=f[i];
		cout<<ans;
	}
	
	return 0;
}