#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<queue>
#include<unordered_map>
#include<algorithm>
using namespace std;
inline char nc()
{
	static char buf[1000010],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,1000010,stdin),l==r)?EOF:*l++;
}
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=nc();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=nc();}
    return w?-x:x;
}
void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)print(x/10);
	putchar(x%10+48);
}
const int maxn=1e7;
int n,tot=0,cnt=0;
int head[maxn+5],nex[maxn+5],z[maxn+5],l[maxn+5],dfn[maxn+5],f[maxn+5],sz[maxn+5],ans=0,bj[maxn+5],nb;
long long zd[maxn+5],tag[maxn+5],ls[maxn+5];
priority_queue<pair<long long,int> >s;
int cx[maxn+5];
void add(int x,int y,int v){
    nex[++tot]=head[x];
    head[x]=tot;
    z[tot]=y;
    l[tot]=v;
}
void dfs1(int wz){
    dfn[wz]=++cnt;
    sz[wz]=1;
    for(int i=head[wz];i;i=nex[i]){
        int ne=z[i];
        bj[ne]=l[i];
        dfs1(ne);
        sz[wz]+=sz[ne];
        s.push(make_pair(1ll*l[i]*sz[ne],ne));
        tag[ne]=1ll*l[i]*sz[ne];
    }
}
void hg(int wz){
    pair<long long,int>now=s.top();
    while(tag[now.second]!=now.first){
        s.pop();
        now=s.top();
    }
    zd[dfn[wz]]=now.first;
    for(int i=head[wz];i;i=nex[i]){
        int ne=z[i],pl=l[i];
        tag[ne]=1ll*pl*(n-sz[ne]);
        s.push(make_pair(tag[ne],ne));
        hg(ne);
        tag[ne]=1ll*pl*sz[ne];
        s.push(make_pair(tag[ne],ne));
    }
}
int ef(long long x){
    int l=1,r=nb,kx=1;
    while(l<=r){
        int mid=(l+r)>>1;
        if(ls[mid]>=x)kx=mid,r=mid-1;
        else l=mid+1;
    }
    if(ls[kx]!=x)return 0;
    else return kx;
}
void dfs2(int wz,int op){
    int bh=0,ma=-1;
    for(int i=head[wz];i;i=nex[i]){
        int ne=z[i];
        if(sz[ne]>ma){
            ma=sz[ne];
            bh=ne;
        }
    }
    for(int i=head[wz];i;i=nex[i]){
        int ne=z[i];
        if(ne==bh)continue;
        dfs2(ne,1);
    }
    if(bh){
        dfs2(bh,0);
        
    }cx[zd[dfn[wz]]]++;
        for(int i=head[wz];i;i=nex[i]){
            int ne=z[i];
            if(ne==bh)continue;
            for(int j=dfn[ne];j<=dfn[ne]+sz[ne]-1;j++)cx[zd[j]]++;
        }
        f[wz]+=cx[ef(1ll*bj[wz]*(n-sz[wz]))]-cx[ef(1ll*bj[wz]*sz[wz])];
    if(op)for(int i=dfn[wz];i<=dfn[wz]+sz[wz]-1;i++)--cx[zd[i]];
    return ;
}
signed main()
{
	freopen("treeq.in","r",stdin);
	freopen("treeq.out","w",stdout);
    n=read(n);
    for(int i=2;i<=n;i++){
        int x=read(x),v=read(v);
        add(x,i,v);
    }
    dfs1(1);
    hg(1);
    for(int i=1;i<=n;i++)ls[++nb]=zd[i];
    sort(ls+1,ls+nb+1);
    nb=unique(ls+1,ls+nb+1)-ls-1;
    for(int i=1;i<=n;i++){
        zd[i]=lower_bound(ls+1,ls+nb+1,zd[i])-ls;
    }
    dfs2(1,0);
    for(int i=2;i<=n;i++){
        f[i]+=cx[ef(1ll*bj[i]*sz[i])];
        ans^=f[i];
    }
    printf("%d\n",ans);
	return 0;
}