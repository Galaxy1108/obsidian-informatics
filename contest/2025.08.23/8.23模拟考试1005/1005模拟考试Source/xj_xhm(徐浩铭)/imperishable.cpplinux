/*
2022/10/5联考 T2 往事成风
题意:一个可重集的价值为2^最小的众数
问分裂成若干个可重集后最小的价值和
每次回修改一个数在集合里的数量

T1什么玩意,3100打个der
不考虑修改
每次寻找到一个i,使得sum[i]>=max(a)
使k=sum[i],ans=2^(i+1)-1
然后从这个i开始从右往左扫，找到一个a[j],使得k-a[j]>=max(a)，那就k-=a[j],ans-=2^j
考虑修改，sum和max都可以用线段树维护
找i可以用二分O(logN)找
但是最后一步就很麻烦，感觉没什么log解法
先打再说
O(QN) 64pts

最后的操作太耗时
想不到优化
打个分块吧
一个块内如果最小值比k-max(a)大
整个块都不用扫
如果一个块内总和小于k-max(a)整个块都能删去，预处理一下就行
理想O(Qsqrt(N)logN)
但会被卡到O(QNlogN)/悲
*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,a,b) for(int i=a;i>=b;i--)
#define py puts("Yes")
#define pn puts("No")
#define pt puts("")
#define fe(i,u) for(int i=head[u];i;i=e[i].next)
#define wt(x) write(x),puts("")
#define tx printf("fds")
#define mp make_pair
#define fi first
#define se second
inline ll read(){
	ll x=0,k=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') k=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-48;
		ch=getchar();
	}
	return x*k;
}
void write(int x){
	if(x<0){
		x=-x;
		putchar('-');
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
ll power(int x,int y,ll mod){
	ll num=1;
	while(y){
		if(y&1) num=(num*x)%mod;
		x=x*x%mod;
		y>>=1;
	}
	return num;
}
const ll N=1e6+7,mod=998244353;
ll n,m;
ll ans;
ll a[N];
ll cf[N];
struct tree{
	ll max,num,min;
}t[N*2];
void pu(int id){
	t[id].max=max(t[id<<1].max,t[id<<1|1].max);
	t[id].num=t[id<<1].num+t[id<<1|1].num;
	t[id].min=min(t[id<<1].min,t[id<<1|1].min);
}
void build(int id,int l,int r){
	if(l==r){
		t[id].max=a[l];
		t[id].num=a[l];
		t[id].min=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(id<<1,l,mid);
	build(id<<1|1,mid+1,r);
	pu(id);
}
void update(int id,int l,int r,int x,int k){
	if(l==r){
		t[id].max=k;
		t[id].num=k;
		t[id].min=k;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid) update(id<<1,l,mid,x,k);
	else update(id<<1|1,mid+1,r,x,k);
	pu(id);
}
int querymax(int id,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		return t[id].max;
	}
	int mid=(l+r)>>1,num=0;
	if(L<=mid) num=max(num,querymax(id<<1,l,mid,L,R));
	if(mid<R) num=max(num,querymax(id<<1|1,mid+1,r,L,R));
	return num;
}
int querymin(int id,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		return t[id].min;
	}
	int mid=(l+r)>>1,num=0;
	if(L<=mid) num=min(num,querymin(id<<1,l,mid,L,R));
	if(mid<R) num=min(num,querymin(id<<1|1,mid+1,r,L,R));
	return num;
}
ll querysum(int id,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		return t[id].num;
	}
	int mid=(l+r)>>1;
	ll num=0;
	if(L<=mid) num+=querysum(id<<1,l,mid,L,R);
	if(mid<R) num+=querysum(id<<1|1,mid+1,r,L,R);
	return num;
}
void solve(){
	int l=1,r=n,p=n;
	int maxx=querymax(1,1,n,1,n);
	ll sum=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(querysum(1,1,n,1,mid)>=maxx) r=mid-1,p=mid;
		else l=mid+1;
	}
	ans=(power(2,p+1,mod)-2+mod)%mod;
	if(a[p]==maxx){
		ans=power(2,p,mod)%mod;
		wt(ans);
		return ;
	}
	sum=querysum(1,1,n,1,p)-maxx;
	int h=sqrt(p);
	int now=p;
	while(now>=1){
		if(now>=h&&now-h+1<=now){
			if(querymin(1,1,n,now-h+1,now)>sum){
				now-=h;
			}
			else if(querysum(1,1,n,now-h+1,now)<=sum){
				sum-=querysum(1,1,n,now-h+1,now);
				ans=(ans-(cf[now]-cf[now-h]+mod)%mod+mod)%mod;
				now-=h;
			}
		}
		if(now==0) break;
		if(a[now]<=sum){
			sum-=a[now];
			ans=(ans-power(2,now,mod)+mod)%mod;
		}
		now--;
	}
	wt(ans);
	return ;
}
signed main(){
	freopen("imperishable.in","r",stdin);
	freopen("imperishable.out","w",stdout);
	int sb=read();
	n=read();
	fo(i,1,n)a[i]=read();
	cf[0]=1;
	fo(i,1,200000) cf[i]=(cf[i-1]*2)%mod;
	fo(i,2,200000) cf[i]=(cf[i]+cf[i-1])%mod;
	build(1,1,n);
	solve();
	m=read();
	fo(i,1,m){
		int x=read(),y=read();
		a[x]=y;
		update(1,1,n,x,y);
		solve();
	}
	return 0;
}