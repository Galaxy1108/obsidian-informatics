#include <cstdio>
using namespace std;
#define ll long long
const int N = 10000005;
struct way {
	int lst, v;
}ed[N];
int head[N], cur, now;
int n, fa[N], f[N], w[N], siz[N];
int bz[N];
inline void dfs(int u) {
	siz[u] = 1;
	for (int i(head[u]) ; i ; i = ed[i].lst) {
		dfs(ed[i].v);
		siz[u] += siz[ed[i].v];
	}
}
inline void add(int u, int v) {
	ed[++cur] = (way) {head[u], v};
	head[u] = cur;
}
inline int read() {
	int an(0), ch(getchar());
	for (; ch < 48 || ch > 57 ; ch = getchar());
	for (; ch > 47 && ch < 58 ; ch = getchar())
		an = (an << 3) + (an << 1) + (ch ^ 48);
	return an;
}
int main() {
	freopen("treeq.in", "r", stdin);
	freopen("treeq.out", "w", stdout);
	n = read();
	for (int i(2) ; i <= n ; ++i) {
		fa[i] = read();w[i] = read();
		add(fa[i], i);
	}
	if (n <= 5000) {
		dfs(1);
		for (int i(1) ; i <= n ; ++i) {
			for (int j(1) ; j <= n ; ++j)
				bz[j] = 1;
			int now = fa[i];
			bz[i] = 0;
			while (now) {
				bz[now] = 0;
				now = fa[now];
			}
			int mx(0);
			for (int j(1) ; j <= n ; ++j) {
				ll t;
				if (bz[j])t = 1ll * siz[j] * w[j];
				else t = 1ll * (n - siz[j]) * w[j];
				if (t > mx)mx = t;
			}
			for (int j(1) ; j <= n ; ++j) {
				ll t;
				if (bz[j])t = 1ll * siz[j] * w[j];
				else t = 1ll * (n - siz[j]) * w[j];
				if (t == mx)f[j]++;
			}
		}
		for (int i(1) ; i <= n ; ++i)
			f[0] ^= f[i];
		printf("%d\n", f[0]);
	}
	fclose(stdin);fclose(stdout);
	return 0;
}