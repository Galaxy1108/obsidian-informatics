#include<stdio.h>
#include<map>
#define N 666666
#define pr pair<int,int> 
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int t,n,m,p,q,x[N],y[N],l[N],r[N],o[N],u[N],v[N],w[N],ans1[N],ans2[N];
map<pr,int>mmp;int now1[N],now2[N];
inline void onion(const int&x,const int&y){r[x]=y;y&&(l[y]=x);}
main()
{
	freopen("corridor.in","r",stdin);freopen("corridor.out","w",stdout);
	read(t);read(n);read(m);read(p);
	for(int i=0;i<p;read(x[i]),read(y[i]),mmp[(pr){x[i],y[i]}]=i,++i);
	read(q);
	for(int i=0;i<q;++i)
	{
		read(o[i]);read(u[i]);read(v[i]);
		if(o[i]^2)x[p]=u[i],y[p]=v[i],mmp[(pr){x[p],y[p]}]=w[i]=p,++p;
		else read(w[i]);
	}
	for(int i=1;i<=n;now1[i]=i,++i);
	for(int i=1;i<=m;now2[i]=n+i,++i);
	for(map<pr,int>::iterator it=mmp.begin();it!=mmp.end();++it)
	{
		onion(now1[it->first.first],n+m+(it->second<<1|1));
		onion(now2[it->first.second],n+m+(it->second+1<<1));
		now1[it->first.first]=n+m+(it->second+1<<1);
		now2[it->first.second]=n+m+(it->second<<1|1);
	}
	for(int i=q-1,j;i>=0;--i)if(o[i]^2)
		onion(l[n+m+(w[i]+1<<1)],r[n+m+(w[i]<<1|1)]),
		onion(l[n+m+(w[i]<<1|1)],r[n+m+(w[i]+1<<1)]);
	else
	{
		if(u[i])
		{
			j=u[i];
			if(!r[j]){ans1[i]=u[i];ans2[i]=m+1;continue;}
		}
		else
		{
			j=n+v[i];
			if(!r[j]){ans1[i]=n+1;ans2[i]=v[i];continue;}
		}
		for(;r[j]&&w[i];j=r[j],--w[i]);
		if(w[i])
			if(j-n-m&1)ans1[i]=n+1,ans2[i]=y[j-n-m>>1];
			else ans1[i]=x[j-n-m-1>>1],ans2[i]=m+1;
		else if(j-n-m&1)ans1[i]=x[j-n-m>>1],ans2[i]=y[j-n-m>>1];
			else ans1[i]=x[j-n-m-1>>1],ans2[i]=y[j-n-m-1>>1];
	}
	for(int i=0;i<q;++i)if(o[i]^1)printf("%d %d\n",ans1[i],ans2[i]);
}
/*1~n (1,0)~(n,0)
 *n+1~n+m (0,1)~(0,m)
 *n+m+(i<<1|1)  7
 *n+m+(i+1<<1)  L
 */