#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

typedef long long ll;
const int N = 2e5 + 10;
const int P = 998244353;
struct node
{
	int a, p;
	#define a(x) a[x].a
	#define p(x) a[x].p
}a[N];
int n, ans;


ll qpow(int x, int y)
{
	ll ret = 1, b = x;
	while (y)
	{
		if (y & 1) ans = ans * b % P;
		b = b * b % P;
		y >>= 1;
	}
	return ans;
}

void work()
{
	int l = 1, r = n;
	while (l < r)
	{
		int mid = (l + r + 1) >> 1;
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
}

int main()
{
	int T;
	scanf("%d", &T);
	int q;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i) scanf("%d", &p(x)), a(x) = i;
	work();
	printf("%d\n", ans);
	scanf("%d", &q);
	for (int i = 1; i <= q; ++ i)
	{
		int x, y;
		scanf("%d %d", &x, &y);
		a[x] = y;
		work();
		printf("%d\n", ans);
	}
	return 0;
}
/*
对于集合x而言，一定包含x
处理集合x
将x与从后向前的数y减去与之对应的个数
计算总量

让小的先收
大的后面收拾残局
但是如果大的可以直接搞好
小的就不需要了	

从大的先开始

让左边先出去杀

这里向前推到哪里结束的阈值仍需要确定
二分阈值
*/