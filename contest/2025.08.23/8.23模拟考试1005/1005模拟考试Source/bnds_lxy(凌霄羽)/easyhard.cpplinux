#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')  f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,m,p; 
int dp[3005][3005];//第i个球 
int f[3005][3005];//是达到最小值 
//若从未达到最小值 整体减一仍是合法的 若达到过一次就无法减一 所以一定是唯一的 
signed main()
{
	freopen("easyhard.in","r",stdin);
	freopen("easyhard.out","w",stdout);
	n=read();m=read();p=read();
	int i,j;
	for(i=1;i<=n;i++)  dp[i][0]=1;
	f[0][0]=1;
	for(j=1;j<=m;j++)
	{
		for(i=0;i<=n;i++)
	    {//j操作数i个数 
	  	  	if(i>0)
	  	  	{
	  	  		dp[i][j]=(dp[i][j]+dp[i-1][j-1])%p;
	  	  		f[i][j]=(f[i][j]+f[i-1][j-1]+f[i][j-1])%p;
	  	  		if(i==1)  f[i][j]=(f[i][j]+dp[i][j-1])%p;
	  	  		else  dp[i][j]=(dp[i][j]+dp[i][j-1])%p;
			}
			if(i<n)
			{
				f[i][j]=(f[i][j]+f[i+1][j-1]+f[i][j-1])%p;
				if(i==0)  f[i][j]=(f[i][j]+dp[i+1][j-1])%p;
				else  dp[i][j]=(dp[i][j]+dp[i+1][j-1]+dp[i][j-1])%p;
			}
	  	}
	}
	int s=0;
	for(i=0;i<=n;i++)  s=(s+f[i][m])%p;
	cout<<s<<endl;
	/*for(i=1;i<=m;i++)
	{
		for(j=0;j<=n;j++)  cout<<dp[j][i]<<" ";
		cout<<endl;
	}*/
	return 0;
}
/*
dp i,j,k nm
dp 0 0 0=0 
dp 1 0 0=1
       1=
	   2=
	   3=
dp 0 1 0=1
       1=
       2=
       3=
dpijk=dpijk-1*2+dpi-1j+1k-1+dpi+1j-1k-1
i=0 dpijk-1

dp2 j
*/

