#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 10000010;
int n, tot, ans;
vector <int> vec[N];
ll g[N];
int sz[N], dfn[N], low[N], rev[N];
int val[N], f[N], id[N];
ll mx[N << 2];
vector <tuple <ll, bool, int> > que[N];
map <ll, int> cnt;
void dfs(int x) {
    rev[dfn[x] = ++tot] = x;
    sz[x] = 1;
    for (int y : vec[x]) {
        dfs(y);
        sz[x] += sz[y];
    }
    low[x] = tot;
}
void modify(int k, int l, int r, int x, int y, ll v) {
    if (x <= l && r <= y) {
        mx[k] = max(mx[k], v);
        return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid)
        modify(k << 1, l, mid, x, y, v);
    if (mid < y)
        modify(k << 1 | 1, mid + 1, r, x, y, v);
}
void pushdown(int k, int l, int r) {
    if (l == r) {
        g[l] = mx[k];
        return;
    }
    int mid = (l + r) >> 1;
    mx[k << 1] = max(mx[k << 1], mx[k]);
    mx[k << 1 | 1] = max(mx[k << 1 | 1], mx[k]);
    pushdown(k << 1, l, mid);
    pushdown(k << 1 | 1, mid + 1, r);
}
int read() {
    int res = 0;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar());
    for (; isdigit(ch); ch = getchar())
        res = res * 10 + (ch - '0');
    return res;
}
int main() {
    freopen("treeq.in", "r", stdin);
    freopen("treeq.out", "w", stdout);
    n = read();
    for (int i = 2; i <= n; ++i) {
        vec[read()].emplace_back(i);
        val[i] = read();
    }
    tot = 0;
    dfs(1);
    for (int i = 2; i <= n; ++i) {
        ll tmp = (ll) val[i] * sz[i];
        if (dfn[i] > 1)
            modify(1, 1, n, 1, dfn[i] - 1, tmp);
        if (low[i] < n)
            modify(1, 1, n, low[i] + 1, n, tmp);
        tmp = (ll) val[i] * (n - sz[i]);
        modify(1, 1, n, dfn[i], low[i], tmp);
    }
    pushdown(1, 1, n);
    for (int i = 2; i <= n; ++i) {
        if (dfn[i] > 1) {
            que[dfn[i] - 1].emplace_back((ll) val[i] * sz[i], 1, i);
            que[dfn[i] - 1].emplace_back((ll) val[i] * (n - sz[i]), 0, i);
        }
        que[low[i]].emplace_back((ll) val[i] * sz[i], 0, i);
        que[low[i]].emplace_back((ll) val[i] * (n - sz[i]), 1, i);
    }
    for (int i = 1; i <= n; ++i) {
        ++cnt[g[rev[i]]];
        for (auto j : que[i])
            f[get <2> (j)] += (get <1> (j) ? 1 : -1) * (cnt.count(get <0> (j)) ? cnt[get <0> (j)] : 0);
    }
    for (int i = 2; i <= n; ++i)
        if (cnt.count((ll) val[i] * sz[i]))
            f[i] += cnt[(ll) val[i] * sz[i]];
    for (int i = 2; i <= n; ++i)
        ans ^= f[i];
    printf("%d\n", ans);
    return 0;
}