#include<cstdio>
#include<algorithm>
using namespace std;
namespace IO{
	const int sz=1<<22;
	char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
	inline char gc(){
		return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;
	}
	template<class T> void read(T& x){
		x=0; char c=gc();
		for(;c<'0'||c>'9';c=gc());
		for(;c>='0'&&c<='9';c=gc())
			x=x*10+(c-'0');
	}
	inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
	inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
	template<class T> void write(T x,char c='\n'){
		if(x<0) pc('-'), x=-x;
		if(x==0) pc('0'); int t=0;
		for(;x;x/=10) p[++t]=x%10+'0';
		for(;t;--t) pc(p[t]); pc(c);
	}
	struct F{~F(){flush();}}f;
}
using IO::read;
using IO::write;
const int N=1e6+5;
int n,tot,e[N],dfn[N],pos[N],si[N],g[N][2],s[N],ans[N],a[N<<1],f[N][2],cnt;
long long nt[N<<1];
#include<unordered_map>
unordered_map<long long,int> ma;
#include<vector>
vector<int> to[N];
inline void dfs(int x)
{
	dfn[x]=++tot;
	pos[tot]=x;
	si[x]=1;
	for(auto y:to[x])dfs(y),si[x]+=si[y];
	if(x==1)return;
	long long v=1ll*si[x]*e[x];
	if(!ma[v])ma[v]=++cnt,nt[cnt]=v;
	f[x][0]=ma[v];
	v=1ll*(n-si[x])*e[x];
	if(!ma[v])ma[v]=++cnt,nt[cnt]=v;
	f[x][1]=ma[v];
}
inline gmax(int x,int y){return nt[x]>nt[y];}
inline void pfs(int x)
{
	for(auto y:to[x])
	{
		pfs(y);
		int v=gmax(g[y][0],f[y][0])?g[y][0]:f[y][0];
		if(gmax(v,g[x][0]))g[x][1]=g[x][0],g[x][0]=v;
		else if(gmax(v,g[x][1]))g[x][1]=v;
	}
}
inline void rfs(int x,int v)
{
	if(gmax(f[x][1],v))v=f[x][1];
	s[x]=gmax(g[x][0],v)?g[x][0]:v;
	for(auto y:to[x])
	{
		int u=g[x][0],v=gmax(g[y][0],f[y][0])?g[y][0]:f[y][0];
		if(v==u)u=g[x][1];
		rfs(y,gmax(v,u)?v:u);
	}
}
struct node{int x,v,id;};
vector<node> q[N];
int main()
{
	freopen("treeq.in","r",stdin);
	freopen("treeq.out","w",stdout);
	read(n);
	for(int i=2;i<=n;i++)
	{
		read(si[i]);read(e[i]);
		to[si[i]].push_back(i);
	}
	tot=0;
	dfs(1);
	pfs(1);
	rfs(1,0);
	for(int i=2;i<=n;i++)
	{
		q[dfn[i]-1].push_back((node){f[i][1],-1,i});
		q[dfn[i]+si[i]-1].push_back((node){f[i][1],1,i});
		q[n].push_back((node){f[i][0],1,i});
		q[dfn[i]-1].push_back((node){f[i][0],1,i});
		q[dfn[i]+si[i]-1].push_back((node){f[i][0],-1,i});
	}
	for(int i=1;i<=n;i++)
	{
		a[s[pos[i]]]++;
		for(auto x:q[i])ans[x.id]+=x.v*a[x.x];
	}
	for(int i=2;i<=n;i++)ans[1]^=ans[i];
	write(ans[1]);
	return 0;
}