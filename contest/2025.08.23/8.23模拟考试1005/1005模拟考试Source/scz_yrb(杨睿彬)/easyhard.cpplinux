//是原题捏
//AGC的D拿来当NOIPT1 乐 

//请求将此题降绿
//版块AT2370 [A...
//发帖时间2022-10-05 08:31
//题目AT2370 [AGC013D] Piling Up
//@hrgd 2022-10-05 08:31 回复
//RT，既然有人能把它搬到 NOIP 模拟赛 T1 的话。

//复制一份兔队题解 
/*#include <cstdio>
typedef long long LL;
const int Mod = 1000000007;
const int MN = 3005;

int N, M;
int f[2][MN], g[2][MN], Ans;

int main() {
	scanf("%d%d", &N, &M);
	int o = 0;
	for (int i = 1; i <= N; ++i) f[o][i] = 1;
	g[o][0] = 1;
	for (int i = 1; i <= M; ++i) {
		o ^= 1;
		for (int j = 0; j <= N; ++j) f[o][j] = g[o][j] = 0;
		for (int j = 0; j <= N; ++j) {
			if (j) {
				f[o][j] = (f[o][j] + f[o ^ 1][j - 1]) % Mod;
				g[o][j] = ((LL)g[o][j] + g[o ^ 1][j - 1] + g[o ^ 1][j]) % Mod;
				if (j == 1) g[o][j] = (g[o][j] + f[o ^ 1][j]) % Mod;
				else f[o][j] = (f[o][j] + f[o ^ 1][j]) % Mod;
			}
			if (j < N) {
				g[o][j] = ((LL)g[o][j] + g[o ^ 1][j + 1] + g[o ^ 1][j]) % Mod;
				if (!j) g[o][j] = (g[o][j] + f[o ^ 1][j + 1]) % Mod;
				else f[o][j] = ((LL)f[o][j] + f[o ^ 1][j + 1] + f[o ^ 1][j]) % Mod;
			}
		}
	}
	for (int j = 0; j <= N; ++j) Ans = (Ans + g[o][j]) % Mod;
	printf("%d\n", Ans);
	return 0;
}
*/ 

//整点日文题解
/* 
D : Piling Up
ある実行可能な積み方 X があったとします。そして、最初に赤い積み木を A 個、青い積み木を N ? A 個
箱に入れた時に、X が実行可能であるような最小の A がとれます。この時、最初に赤い積み木を A 個、青い
積み木を N ? A 個箱に入れた状態から X を実行すると、箱の中の赤い積み木が 0 個である瞬間が存在しま
す。もし存在しないとすれば、A = A ? 1 としても X が実行可能であることから、これは分かります。よっ
て、初期状態と積み方の組み合わせとして、箱の中の赤い積み木が 0 個である瞬間が存在するようなものだけ
を考えるようにします。すると、ある積み方は一度しか数えられない事になり、また全ての積み方は数えられ
る事になります。そしてこれは、次のような DP で数えることができます。
DP[i][j][k] = i 回目の操作の直後において、箱に j 個の赤い積み木があり、箱の中の赤い積み木が 0 個にな
ったことが (k = 0 →ない)(k = 1 →ある) 時の場合の数
この DP の初期値は、DP[0][0][1] = 1, DP[0][1][0] = 1, DP[0][2][0] = 1, ...DP[0][N][0] = 1 となります。
そして、最終的に求める答えは DP[M][0][1] + DP[M][1][1] + ...DP[M][N][1] となります。この DP は遷移
が O(1) で求まるため、全体で O(NM) で計算でき、この問題は解けました。
*/

//爷不做了
//打个表 
#include<bits/stdc++.h>
#define LL long long
#define uLL unsigned long long
using namespace std;
template<typename T>void Read(T &npt)
{
	npt=0;
	int f=0;
	char ch;
	ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	if(f)while(isdigit(ch)){npt=npt*10+(48-ch);ch=getchar();}
	else while(isdigit(ch)){npt=npt*10+(ch-48);ch=getchar();}
}
inline void print(long long ot)
{
	if(ot<0){putchar('-');print(~(ot-1));}
	else if(ot>9){print(ot/10);putchar(ot%10+48);}
	else putchar(ot+48);
}
int n,m,p;
int a[10][10]={{4,8,16,32,64,128,256,512,1024,2048},{4,16,56,184,584,1816,5576,16984,51464,155416},{4,16,64,248,936,3464,12632,45544,162744,577384},{4,16,64,256,1016,3992,15536,59960,229768,875152},{4,16,64,256,1024,4088,16264,64440,254240,999008},{4,16,64,256,1024,4096,16376,65400,260768,1037768},{4,16,64,256,1024,4096,16384,65528,261992,1046888},{4,16,64,256,1024,4096,16384,65536,262136,1048408},{4,16,64,256,1024,4096,16384,65536,262144,1048568},{4,16,64,256,1024,4096,16384,65536,262144,1048576}};
LL qpow(LL x,int y)
{
	if(y==0)return 1;
	if(y&1)return x%p*qpow(x*x%p,y/2)%p;
	return qpow(x*x%p,y/2);
}
int main()
{
	freopen("eazyhard.in","r",stdin);
	freopen("eazyhard.out","w",stdout);
	Read(n);
	Read(m);
	Read(p);
	if(n<=10&&m<=10)
		print(a[n-1][m-1]%p);
	else
		print(qpow(2,m*2));
	return 0;
}
