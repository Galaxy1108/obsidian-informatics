#include<bits/stdc++.h>
#define ll long long
ll n, m, p;
/* 
	取两个同色 剩下异色 取两个异色 剩下同色 
	可以搞 n^2 但是 状压不好搞
	状态不好处理
	*** 可以发现 其他球的用处就是形成三连往上走 不然就纯费 *** 
	把 2m 两两组成一组 
	所有东西都是用来决定第 2i + 1 个的
	无论如何 第 2i 个数字都可以乱搞  但是对后续的东西有点影响 
	现在的问题在于 后面可以接什么球
	把未知球看做任意球
	当场上只有同色时使用任意球！ 
	先考虑 n >= m 时 骗分 
	定义dp[i][j][k] 表示前i个 剩下 j 个黑 剩下 k 个任意球 
*/
using namespace std;
ll dp[300][300][300]; 
ll km(int a, int b){
	if(b == 0) return 1;
	if(b & 1) return a * km(a, b - 1) % p;
	ll cun =  km(a, b / 2) % p;
	return cun * cun % p;
}

int main(){
	freopen("easyhard.in", "r", stdin);
	/reopen("easyhard.out","w", stdout);
	scanf("%d%d%d", &n, &m, &p);
	if(n >= m){
		printf("%lld", km(2, 2 * m));
	} else{
		memset(dp, 0, sizeof(dp));
		dp[1][1][1] = 2; //相当于黑球开局 
		for(int i = 2; i <= m * 2; i ++) {//枚举状态 ——> 位置 
			for(int k = 1; k <= n; k ++){ // 枚举任意球的个数 
				for(int j = 0; j <= k; j ++){ // 枚举剩下的黑球个数 
					if(i % 2 == 0 ) //偶数位置 不能使用任意球 
						dp[i][j][k] = dp[i - 1][j + 1][k] + dp[i - 1][j][k]; //选黑球和不选黑球 OK
					//———————————————————————————————————————————— 
					else if(j != 0)
						dp[i][j][k] = dp[i - 1][j][k] + 2 * dp[i - 1][j - 1][k - 1] + dp[i - 1][j - 1][k]; //选择黑球 使用任意球（选黑）（会跟前面的状态有重复） 不选黑球   使用任意球（选白） 
				}
			}
			//for(int j = 0; j <= n; j ++)
			//	for(int k = 1; k <= n; k ++)
			//		cout << i <<":"<<"you have black :"<<j<<" use niubi :"<<k<<" your choose :"<<dp[i][j][k] << endl; 
		}
		ll ans = 0;
		for(int j = 0; j <= n; j ++){
			for(int k = 1; k <= n; k ++)
				ans += dp[2 * m][j][k];
		} 
		cout << ans;
	}
	
	return 0 ;
} 