/*
题意：设F(i)=(i,0)*(i,1)*(i,2)*....*(i,i)
设G(i)为F(i)的因数的和
求sigma(G[i]) [1,n]

可以得到F(i)的递推式:F(i+1)=F(i)*((i+1)^(i+1))/(x+1)!

然后可以得到每个F(i)的唯一分解式
然后就可以得到G(i)=(p1^(d1+1)-1)/(p1-1)*(p2^(d2+1)-1)/(p2-1)*....*(pn^(dn+1)-1)/(pn-1)
然后就通不过mod为合数的点了
哈哈哈哈

*/

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,a,b) for(int i=a;i>=b;i--)
#define py puts("Yes")
#define pn puts("No")
#define pt puts("")
#define fe(i,u) for(int i=head[u];i;i=e[i].next)
#define wt(x) write(x),puts("")
#define tx printf("fds")
#define mp make_pair
#define pb push_back
#define fi first
#define se second
inline int read(){
	int x=0,k=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') k=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-48;
		ch=getchar();
	}
	return x*k;
}
void write(int x){
	if(x<0){
		x=-x;
		putchar('-');
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int power(int x,int y,int mod){
	int num=1;
	while(y){
		if(y&1) num=(num*x)%mod;
		x=x*x%mod;
		y>>=1;
	}
	return num;
}
int mul(int x,int y,int mod){
	int num=0;
	while(y){
		if(y&1) num=(num+x)%mod;
		x=(x+x)%mod;
		y>>=1;
	}
	return num;
}
const int N=1e5+7;
int mod;
int n,m,t,tot,cnt,ans;
int jc[N],f[N],is_prime[N],prime[N],jcprime[N],primenum[N];
void prime_phi(int x){
	fo(i,2,x){
		if(!is_prime[i]){
			prime[++tot]=i;
			// phi[i]=i-1;
		}
		fo(j,1,tot){
			if(prime[j]*i>x) break;
			is_prime[prime[j]*i]=1;
			// if(prime[j]*i%(prime[j]*prime[j])==0) phi[prime[j]*i]=prime[j]*phi[i];
			// else phi[prime[j]*i]=phi[prime[j]]*phi[i];
			if(i%prime[j]==0) break;
		}
	}
}
signed main(){
	freopen("gonna.in","r",stdin);
	freopen("gonna.out","w",stdout);
	n=read();mod=read();
	prime_phi(n*2);
	jc[0]=1;
	fo(i,1,n) jc[i]=jc[i-1]*i%mod;
	f[0]=1;
	f[1]=1;
	fo(i,2,n){
		int num=i;
		fo(j,1,tot){
			if(prime[j]>i) break;
			while(num%prime[j]==0){
				jcprime[j]++;
				primenum[j]+=i;
				num/=prime[j];
			}
		}
		int p=1;
		fo(j,1,tot){
			if(prime[j]>i) break;
			primenum[j]-=jcprime[j];
			p=p*(power(prime[j],primenum[j]+1,mod)-1+mod)%mod*power(prime[j]-1,mod-2,mod)%mod;
		}
		ans=(ans+p)%mod;
	}
	wt(ans+1);
	return 0;
}