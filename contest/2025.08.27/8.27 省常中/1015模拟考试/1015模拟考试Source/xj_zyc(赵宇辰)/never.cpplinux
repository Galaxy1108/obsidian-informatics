#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#define bb bool
#define cc char
#define dd double
#define gc getchar
#define int __int128
#define inf 1e18
#define mod 998244353
#define lc p<<1
#define rc p<<1|1
#define ll long long
#define pc putchar
#define pt puts("")
#define rr return
#define RS 100010
#define ss string
#define vv void
#define ww while
#define f(a,b,c) for(int c=a;c<=b;++c)
#define ff(a,b,c) for(int c=a;c>=b;--c)
#define f1(a,b,c,d) for(int c=a;c<=b;c+=d)
#define f2(a,b,c,d) for(int c=a;c>=b;c-=d)
#define f3(u,c) for(int c=h[u];c;c=e[c].nt)
using namespace std;
//namespace Fread{const int SIZE=1<<20;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return'\n';}return*S++;}}using namespace Fread;namespace Fwrite{const int SIZE=1<<20;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}using namespace Fwrite;namespace Fastio{struct Reader{template<typename T>Reader&operator>>(T&x){x=0;short f=1;char c=Fread::getchar();while(c<'0'||c>'9'){if(c=='-')f*=-1;c=Fread::getchar();}while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=Fread::getchar();x*=f;return*this;}Reader&operator>>(double&x){x=0;double t=0;short f=1,s=0;char c=Fread::getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=Fread::getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=Fread::getchar();if(c=='.')c=Fread::getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=Fread::getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(char&c){c=Fread::getchar();while(c==' '||c=='\n'||c=='\r')c=Fread::getchar();return*this;}Reader&operator>>(char*str){int len=0;char c=Fread::getchar();while(c==' '||c=='\n'||c=='\r')c=Fread::getchar();while(c!=' '&&c!='\n'&&c!='\r')str[len++]=c,c=Fread::getchar();str[len]='\0';return*this;}Reader&operator>>(string&str){str.clear();char c=Fread::getchar();while(c==' '||c=='\n'||c=='\r')c=Fread::getchar();while(c!=' '&&c!='\n'&&c!='\r')str.push_back(c),c=Fread::getchar();return*this;}Reader(){}}cin;struct Writer{const int Setprecision=6;typedef int mxdouble;template<typename T>Writer&operator<<(T x){if(x==0){Fwrite::putchar('0');return*this;}if(x<0)Fwrite::putchar('-'),x=-x;static short sta[40];short top=0;while(x>0)sta[++top]=x%10,x/=10;while(top>0)Fwrite::putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(double x){if(x<0)Fwrite::putchar('-'),x=-x;mxdouble _=x;x-=(double)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)Fwrite::putchar('0');while(top>0)Fwrite::putchar(sta[top]+'0'),top--;Fwrite::putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)Fwrite::putchar('0');while(top>0)Fwrite::putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(char c){Fwrite::putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])Fwrite::putchar(str[cur++]);return*this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])Fwrite::putchar(str[cur++]);return*this;}Writer&operator<<(string str){int st=0,ed=str.size();while(st<ed)Fwrite::putchar(str[st++]);return*this;}Writer(){}}cout;}using namespace Fastio;
//#define cin Fastio::cin
//#define cout Fastio::cout
//#define endl '\n'
//头文件
int rd(){ int w=0,v=1; cc c=gc(); if(c==EOF){ rr 0;} ww(c<'0'||c>'9'){ if(c=='-'){
v=-1;} c=gc();} ww(c>='0'&&c<='9'){ w=(w<<1)+(w<<3)+(c&15); c=gc();} rr w*v;}
vv wr(int x){ cc c[20]={}; int l=0; if(x<0){ pc((1<<5)+(1<<3)+(1<<2)+1); x=~x+1;}
do{ c[++l]=x%10+(1<<4)+(1<<5); x/=10;}ww(x>0); f2(l,1,i,1){ pc(c[i]);} rr;}
ss Srd(){ ss s; cc c=gc(); ww(c==' '||c=='\n'||c=='\r'){ c=gc();}
ww(c!=' '&&c!='\n'&&c!='\r'&&c!=EOF){ s+=c; c=gc();} rr s;}
vv Swr(ss s){ int l=s.length(); f1(0,l-1,i,1){ pc(s[i]);}}
//快读快写
vv swaP(int &x,int &y){ x^=y,y^=x,x^=y;}//交换
int avE(int x,int y){ rr (x&y)+((x^y)>>1);}//平均数
int maX(int x,int y){ rr x>y?x:y;}//最大值
int miN(int x,int y){ rr x<y?x:y;}//最小值
int ceL(int x,int y){ rr x/y+(x%y!=0);}//上取整
int ksm(int a,int b){ int ans=1; ww(b){ if(b&1){
ans=(ans*a)%mod;} a=(a*a)%mod; b>>=1;} rr ans;}//快速幂
int gcd(int x,int y){ if(x>y){ swaP(x,y);}
ww(x){ y%=x; swaP(x,y);} rr y;}//最大公约数
int lcm(int x,int y){ rr x/gcd(x,y)*y;}//最小公倍数
//实用函数
//int cnt=1,h[RS]; struct nd{ int v,nt;}e[RS<<1];
//vv add(int u,int v){ e[++cnt].v=v; e[cnt].nt=h[u]; h[u]=cnt;}
//建图
int T,n,s,t,x,y;
signed main(){
	freopen("never.in","r",stdin);
	freopen("never.out","w",stdout);
	T=rd();
	ww(T--){
		n=rd(); s=rd(); t=rd(); x=rd(); y=rd();
		int l=-inf,r=0,ans=0,g1=t-s-(n-1)*y,g2=t-s-n*y-x;
		ww(l<=r){
			int mid=(l+r)/2;
			if(mid*(x+y)>g1){
				r=mid-1;
			}else if(g2>mid*(x+y)){
				l=mid+1;
			}else{
				if(mid*(x+y)==g1) ans=mid-1;
				else ans=mid;
				break;
			}
		} wr(s+ans*x+(n+ans)*y); cout<<endl;
	} rr 0;
}