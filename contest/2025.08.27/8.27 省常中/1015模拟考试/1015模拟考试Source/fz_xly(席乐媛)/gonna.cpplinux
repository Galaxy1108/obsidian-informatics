#pragma GCC optimize(2)
#include<cstdio>
using namespace std;
const int N=2e4+5;
int pri[N],num,rev[N],cot[N],a[N][10],b[N][10],mod,tot[N];
bool vis[N];
int redd(){
	int xx=0,fl=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-'){ch=getchar();fl=-1;}
	for(;ch>='0'&&ch<='9';ch=getchar())
		xx=(xx<<3)+(xx<<1)+ch-'0';
	return xx*fl;
}
int maxx(int x,int y){
	return x>y?x:y;
}
int mul(int x,int y){
	int t=(int)((1.0L*x*y)/(1.0L*mod));
	x=x*y-t*mod;
	x-=mod;
	while(x<0)x+=mod;
	return x;
}
int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=mul(res,x);
		x=mul(x,x);
		y>>=1;
	}
	return res;
}
int main(){
	freopen("gonna.in","r",stdin);
	freopen("gonna.out","w",stdout);
	int n,ans,now,mx=0;
	n=redd();mod=redd();
	for(int i=2;i<=n;i++){
		if(!vis[i]){pri[++num]=i;rev[i]=num;}
		for(int j=1;j<=num&&i*pri[j]<=n;j++){
			vis[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
	for(int i=1;i<=n;i++){
		int j=i;
		for(int k=1;k<=num&&pri[k]*pri[k]<=i&&j>1;k++)if(j%pri[k]==0){
			a[i][++a[i][0]]=k;
			while(j%pri[k]==0)j/=pri[k],b[i][a[i][0]]++;
			mx=maxx(mx,k);
		}
		if(j>1){a[i][++a[i][0]]=rev[j];b[i][a[i][0]]=1;mx=maxx(mx,rev[j]);}
	}
	ans=0;now=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a[i][0];j++){
			now=mul(now,ksm(mul((ksm(pri[a[i][j]],cot[a[i][j]]+1)-1+mod)%mod,ksm(pri[a[i][j]]-1,mod-2)),mod-2));
			cot[a[i][j]]+=i*b[i][j];
			now=mul(now,mul((ksm(pri[a[i][j]],cot[a[i][j]]+1)-1+mod)%mod,ksm(pri[a[i][j]]-1,mod-2)));
			tot[a[i][j]]+=b[i][j];
		}
		for(int j=1;j<=mx;j++){
			now=mul(now,ksm(mul((ksm(pri[j],cot[j]+1)-1+mod)%mod,ksm(pri[j]-1,mod-2)),mod-2));
			cot[j]-=tot[j];
			now=mul(now,mul((ksm(pri[j],cot[j]+1)-1+mod)%mod,ksm(pri[j]-1,mod-2)));
		}
		ans=(ans+now)%mod;
	}
	printf("%d\n",ans);
	return 0;
}