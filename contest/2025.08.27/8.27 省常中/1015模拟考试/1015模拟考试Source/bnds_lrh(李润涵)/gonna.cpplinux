#include<iostream>
#include<cstdio>
#include<memory.h>
using namespace std;
struct node{int nxt, to, v;}edge[300005];
int n, p, cnt, head[3005], qya[3005];
long long ny[3005], ans;
long long ksm(int x, int y)
{
	if(!y)
		return 1;
	else if(y==1)
		return x;
	long long num=ksm(x, y>>1);
	return (num*num)%p*ksm(x, y&1)%p;
}
void pre(int x)
{
	int qya=x, i=2;
	for(; qya>=i*i; i++)
		if(qya%i==0)
		{
			edge[++cnt]=(node){head[x], i, 0};
			head[x]=cnt;
			while(qya%i==0)
			{
				qya=qya/i;
				edge[cnt].v++;
			}
		}
	if(qya>1)
	{
		edge[++cnt]=(node){head[x], qya, 1};
		head[x]=cnt;		
	}
}
int main()
{
	freopen("gonna.in", "r", stdin);
	freopen("gonna.out", "w", stdout);
	scanf("%d%d", &n, &p);
	for(int i=1; i<=n; i++)
		pre(i);
	for(int i=1; i<=n; i++)
		ny[i]=ksm(i, p-2);
	for(int i=1; i<=n; i++)
	{
		long long k=1;
		memset(qya, 0, sizeof(qya));
		for(int j=1; j<=i; j++)
			for(int l=head[j]; l; l=edge[l].nxt)
				qya[edge[l].to]+=edge[l].v*(2*j-i-1)%p;
		for(int j=1; j<=i; j++)
			if(qya[j])
			{
				k*=ny[j-1]*(ksm(j, qya[j]+1)-1)%p;
				k%=p;			
			}
		ans+=k;
		ans%=p;
	}
	printf("%lld", ans);
	fclose(stdin);
	fclose(stdout);
}