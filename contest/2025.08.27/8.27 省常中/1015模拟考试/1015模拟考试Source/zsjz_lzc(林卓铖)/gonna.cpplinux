#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;
typedef __uint128_t L;
struct FastMod {
  ull b, m;
  FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
  ull operator()(ull a) {
    ull q = (ull)((L(m) * a) >> 64);
    ull r = a - q * b; // can be proven that 0 <= r < 2*b
    return r >= b ? r - b : r;
  }
};
FastMod R(2);

int mod;
void add(int &x, int y) { if ((x += y - mod) < 0) x += mod; }
int mpowsum(int a, int b) {
  int ret = 0, sum = 1;
  for (; b; b >>= 1) {
    if (b & 1) ret = R((ull)ret * a + sum);
    sum = R((ull)(a + 1) * sum), a = R((ull)a * a);
  }
  return ret;
}

const int N = 2e4;
const int B = 1e4;
const int CNT = 2262;

int n;
int vis[N + 5], cnt, prime[N + 5];
int f[CNT + 5], ans;
int v[CNT + 5][N + 5];

struct monoid {
  int a, b, c;
  monoid(int a = 0, int b = 0, int c = 0): a(a), b(b), c(c) {}
  static monoid identity() { return monoid(1, 0, 1); }
  monoid operator*(const monoid &o) const { return monoid(R((ull)a * o.a), R((ull)a * o.b + (ull)b * o.c), R((ull)c * o.c)); }
} pw[CNT + 5][2][B + 5];
int merge(monoid a, monoid b) {
  return R((ull)a.a * b.b + (ull)a.b * b.c);
}

int main() {
  freopen("gonna.in", "r", stdin), freopen("gonna.out", "w", stdout);
  scanf("%d%d", &n, &mod), R = FastMod(mod);
  for (int i = 2; i <= n; ++i) {
    if (!vis[i]) prime[++cnt] = i;
    for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
      vis[i * prime[j]] = 1;
      if (!(i % prime[j])) break;
    }
  }
  for (int k = 1; k <= cnt; ++k) {
    int p = prime[k];
    for (int i = 1; i <= n; ++i)
      v[k][i] = v[k][i / p] + i / p;
    monoid x(p, 1, 1);
    pw[k][0][0] = pw[k][1][0] = monoid::identity();
    for (int i = 1; i <= B; ++i)
      pw[k][0][i] = pw[k][0][i - 1] * x;
    for (int i = 1; i < B; ++i)
      pw[k][1][i] = pw[k][1][i - 1] * pw[k][0][B];
  }
  for (int i = 1; i <= n; ++i) f[i] = 1;
  for (int k = 1; k <= cnt; ++k) {
    int p = prime[k];
    for (int i = 1; i <= n; ++i) {
      int e = (i - 1) * v[k][i] - 2 * v[k][i - 1] + 1;
      f[i] = R((ull)f[i] * merge(pw[k][1][e / B], pw[k][0][e % B]));
      v[k][i] += v[k][i - 1];
    }
  }
  for (int i = 1; i <= n; ++i) add(ans, f[i]);
  printf("%d\n", ans);
}