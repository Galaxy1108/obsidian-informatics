#include <cstdio>
#include <iostream>
#include <cstring>
#define macro_expand(x) #x
#define print_macro(x) printf("%s\n",macro_expand(x))
#define FOR(i,l,r) for(int i=(l),i##ADJK=(r);i<=i##ADJK;++i)
#define ROF(i,r,l) for(int i=(r),i##ADJK=(l);i>=i##ADJK;--i)
using namespace std;
typedef long long LL;
const int MN=55,MM=205,MS=505;
int T,A[MN],M,N,S;
bool f[MN][MM][MS];
bool binom(int u,int d){return (u|d)==u;}
int main(){
	freopen("give.in","r",stdin);
	freopen("give.out","w",stdout);
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&M,&S,&N);
		memset(f,0,sizeof(f));
		int mx=0;
		FOR(i,1,N){
			scanf("%d",&A[i]);
			mx=max(mx,A[i]);
		}
		if(S>mx*M){
			printf("0\n");
			continue;
		}
		f[0][0][0]=1;
		// f[i][j][k]前 i 种数，已经填了 j 个位置，总和为 k 的方案数
		// 下一种数填了 l 个，枚举 l 进行转移，每次在剩下的 M-j 个位置里面选择 l 个填上
		FOR(i,0,N-1)FOR(j,0,M)FOR(k,0,S){
			if(!f[i][j][k])continue;
			FOR(l,0,M-j){
				if(k+l*A[i+1]>S)break;
				f[i+1][j+l][k+l*A[i+1]]^=(f[i][j][k]&binom(M-j,l));
			}
		}
		printf("%d\n",f[N][M][S]);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}