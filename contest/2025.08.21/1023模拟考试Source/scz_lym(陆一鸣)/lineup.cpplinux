# include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n;
int a[N];
int b[N],c[N];
bool flag[N];
int dist[N];
int L[N],R[N];
int Match[N],id[N],fid[N];
struct cmp
{
	bool operator ()(const int &X,const int &Y)
	{
		if(dist[X] ^ dist[Y]) return dist[X] > dist[Y];
		else return a[fid[X]] < a[fid[Y]];
	}
};
priority_queue <int,vector<int>,cmp> Q;
bool check(void)
{
	for(int i = 1; i <= n; i++)
	{
		if(a[i] ^ c[i]) return 0;
	}
	return 1;
}
void print(int a[])
{
	for(int i = 1; i <= n; i++) printf("%d ",a[i]);
	printf("\n");
}
int main(void)
{
	freopen("lineup.in","r",stdin);
	freopen("lineup.out","w",stdout);
	scanf("%d",&n);
	for(int i = 1; i <= n; i++) scanf("%d",&a[i]),b[i] = a[i];
	sort(b + 1, b + n + 1);
	for(int i = 1; i <= n; i++) c[i] = b[i];
	int LL = unique(b + 1, b + n + 1) - b - 1;
	for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + LL + 1,a[i]) - b,c[i] = lower_bound(b + 1, b + LL + 1, c[i] ) - b;
	L[1] = 1,R[c[n]] = n;
	for(int i = 2; i <= n; i++)
	{
		if(c[i] != c[i - 1]) R[c[i - 1]] = i - 1,L[c[i]] = i;
		
	}
	
	for(int i = 1; i <= n; i++)
	{
		if(i <= L[a[i]]) 
		{
			for(int j = L[a[i]]; j <= R[a[i]]; j++)
			{
				if(!flag[j]) 
				{
					dist[i] = abs(i - j),flag[j] = 1; Match[i] = j;
					break;
				}
			}
		}
		else if(i > R[a[i]])
		{
			for(int j = R[a[i]]; j >= L[a[i]]; j--)
			{
				if(!flag[j])
				{
					dist[i] = abs(i - j); Match[i] = j;
					flag[j] = 1;
					break;
				}
			}
		}
		else
		{
			for(int d = 0; d <= max(R[a[i]] - i,L[a[i]] - i); d++)
			{
				if(i - d >= 1 && c[i - d] == a[i] && !flag[i - d]) 
				{
					dist[i] = d;
					Match[i] = i - d;
					flag[i - d] = 1; break;
				}
				else if(i + d <= n && c[i + d] == a[i] && !flag[i + d])
				{
					dist[i] = d;
					Match[i] = i + d;
					flag[i + d] = 1; break;
				}
			}
		}
	}
	for(int i = 1; i <= n; i++) fid[i] = id[i] = i;
	for(int i = 1; i <= n; i++) 
	{
		Q.push(i);
	}
	int count = 0;
	while(!Q.empty() && (!check()))
	{
		int x = Q.top(); Q.pop();
		if(dist[x] == 0) continue;
		count += 2 * dist[x];
//		printf("swap : %d,%d,x = %d,Match = %d,delta = %d,count = %d\n",fid[x],fid[Match[x]],x,Match[x],2 * dist[x],count);
		int Mt = id[Match[x]];
		swap(a[fid[x]],a[Match[x]]);
		id[fid[x]] = id[Match[x]];
		swap(fid[x],fid[id[Match[x]]]);
		id[fid[x]] = x;
		dist[x] = 0;
//		dist[id[Match[x]]] = abs(Match[id[Match[x]]]- fid[id[Match[x]]]);
		dist[Mt] = abs(Match[Mt]-fid[Mt]);
//		printf("resolve:dis[%d] = %d\n",Mt,dist[Mt]);
//		printf("a:\n");
		print(a);
		//重新计算Match[x]的dist,Match
//		int y = Match[x]; Match[x] = -1;
//		flag[fid[Match[y]]] = 0;
//		printf("flag:\n");
//		print(flag);
//		printf("fid[%d] = %d,a[%d] = %d\n",y,fid[y],fid[y],a[fid[y]]);
//		if(fid[y] <= L[a[fid[y]]])
//		{
//			printf("case 1\n");
//			for(int i = L[a[fid[y]]]; i <= R[a[fid[y]]]; i++)
//			{
//				if(!flag[i])
//				{
//					Match[y] = id[i];dist[y] = abs(fid[y] - i);
//					printf("i = %d\n",i);
//					flag[i] = 1;
//					break;
//				}
//			}
//		}
//		else if(fid[y] > R[a[fid[y]]])
//		{
//			for(int i = R[a[fid[y]]]; i >= L[a[fid[y]]]; i--)
//			{
//				if(!flag[i])
//				{
//					Match[y] = id[i];dist[y] = abs(fid[y] - i);
//					flag[i] = 1;
//					break;
//				}
//			}
//		}
//		else
//		{
//			for(int d = 0; d <= max(R[a[fid[y]]] - fid[y],L[a[fid[y]]] - fid[y]); d++)
//			{
//				if(fid[y] - d >= 1 && c[fid[y] - d] == a[fid[y]] && !flag[fid[y] - d])
//				{
//					Match[y] = id[fid[y] - d]; dist[y] = d;
//					flag[fid[y] - d] = 1;
//					break;
//				}
//				else if(fid[y] + d <= n && c[fid[y] + d] ==a[fid[y]] && !flag[fid[y] + d])
//				{
//					Match[y] = id[fid[y] + d]; dist[y] = d;
//					flag[fid[y] + d] = 1;
//					break;
//				}
//			}
//		}
//		printf("resolve:Match[%d] = %d,dist[%d] = %d\n",y,Match[y],y,dist[y]);
	}
	printf("%d\n",count);
	return 0;
}
