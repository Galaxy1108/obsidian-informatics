#include<bits/stdc++.h>
using namespace std;
struct modint{
    #define mod 1'000'000'007
    int x;modint(int o=0) {x=o;}
    modint &operator = (int o) {return x=o,*this;}
    modint &operator += (modint o) {return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint &operator *= (modint o) {return x=1ll*x*o.x%mod,*this;}
    modint &operator -= (modint o) {return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint &operator ^= (int b) {
        modint a=*this,c=1;for(;b;b>>=1,a=a*a) if(b&1) c*=a;return x=c.x,*this;
    }bool operator ! () {return !x;}
    friend modint operator + (modint a,modint b) {return a+=b;}
    friend modint operator * (modint a,modint b) {return a*=b;}
    friend modint operator - (modint a,modint b) {return a-=b;}
    friend modint operator ^ (modint a,int k) {return a^k;}
    friend inline istream&
    operator>>(istream& _is,modint& _b){return _is>>_b.x;}
    friend inline ostream&
    operator<<(ostream& _os,const modint& _b){return _os<<_b.x;}
};
namespace DF{
    #define fi first
    #define se second
    #define mk make_pair
    #define pc putchar
    #define emp emplace_back
    #define all(x) x.begin(),x.end()
    #define FOR(i,j,k) for(int i=j;i<=k;++i)
    #define ROF(i,j,k) for(int i=j;i>=k;--i)
    template<typename x,typename y> 
    ostream& operator<<(ostream& _os,const pair<x,y> &pp) {
        return _os<<'{'<<pp.fi<<','<<pp.se<<'}';
    }
    template<typename A> 
    ostream& operator<<(ostream& _os,const vector<A> &vc) {
        _os<<'{';for(A &x:vc) _os<<x<<',';return _os<<'}';
    }
    template<typename T>
    inline void print(T *f,int n) {
        cout<<'{';FOR(i,1,n) cout<<f[i]<<',';cout<<'}'<<endl;
    }
}using namespace DF;
namespace IO{
	template<typename T>
    void rd(T &x) {
        bool f=0;unsigned int ch=getchar();
        for(;(ch^48)>9||(ch^48)<0;ch=getchar())if(ch=='-')f=1;
        for(x=0;(ch^48)<10&&(ch^48)>=0;ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
        if(f) x=-x;
    }
    void pr(int x) {
        if(x>=10) pr(x/10);
        pc(x%10+'0');
    }
}using namespace IO;bool Mbe;
//-------------------------------------------//

const int N=5010;
int n,a[N],Mx=0;
namespace sub1{
    void main() {
        modint ans=0;
        FOR(i,1,Mx-1) {
            modint tmp=1;
            FOR(j,1,n) {
                modint tmpp=a[j];tmpp^=(mod-2);
                tmpp*=min(i,a[j]);
                tmp*=tmpp;
            }
            ans+=tmp;
        }
        cout<<(Mx-ans.x+mod)%mod<<endl;
    }
}
namespace sub2{
    modint fac[N],ifac[N],pre[N],suf[N];
    int lagrange(int n,modint *y,int x) {
        fac[0]=ifac[0]=1;
        FOR(i,1,n) fac[i]=fac[i-1]*i;
        ifac[n]=fac[n];ifac[n]^=(mod-2);
        ROF(i,n-1,1) ifac[i]=ifac[i+1]*(i+1);
        pre[0]=1;
        FOR(i,1,n) pre[i]=pre[i-1]*(x-i);
        suf[n+1]=1;
        ROF(i,n,1) suf[i]=suf[i+1]*(x-i);
        modint ans=0,mc=(mod-1);mc^=(mod-2);
        FOR(i,1,n) {
            modint tmp=y[i];
            if(i>1) tmp*=pre[i-1];
            if(i<n) tmp*=suf[i+1];
            if(i>1) tmp*=ifac[i-1];
            if(i<n) tmp*=ifac[n-i];
            if((n-i)&1) tmp*=mc;
            ans+=tmp;
        } 
        return ans.x;
    }
    modint sum[N];
    void main(){
        FOR(i,1,n+2) {
            modint tmp=i;tmp^=n;
            sum[i]+=sum[i-1]+tmp;
        }
        modint res;
        if(Mx-1<=n+2) res=sum[Mx-1];
        else res=lagrange(n+2,sum,Mx-1);
        modint tmp=Mx;tmp^=n;tmp^=(mod-2);
        res*=tmp;
        cout<<(Mx-res.x+mod)%mod<<endl;
    }
}
namespace sub3{
    modint fac[N],ifac[N],pre[N],suf[N],mc,qwq[N][N];
    inline void init(int n) {
        fac[0]=ifac[0]=1;
        FOR(i,1,n) fac[i]=fac[i-1]*i;
        ifac[n]=fac[n];ifac[n]^=(mod-2);
        ROF(i,n-1,1) ifac[i]=ifac[i+1]*(i+1);
        mc=(mod-1);mc^=(mod-2);
        FOR(i,1,n) {
            qwq[i][0]=1;
            FOR(j,1,n) qwq[i][j]=qwq[i][j-1]*i;
        }
    }
    int c[N],tot=0;
    int lagrange(int n,modint *y,int x) {
        pre[0]=1;
        FOR(i,1,n) pre[i]=pre[i-1]*(x-i);
        suf[n+1]=1;
        ROF(i,n,1) suf[i]=suf[i+1]*(x-i);
        modint ans=0;
        FOR(i,1,n) {
            modint tmp=y[i];
            if(i>1) tmp*=pre[i-1];
            if(i<n) tmp*=suf[i+1];
            if(i>1) tmp*=ifac[i-1];
            if(i<n) tmp*=ifac[n-i];
            if((n-i)&1) tmp*=mc;
            ans+=tmp;
        } 
        return ans.x;
    }
    modint sum[N];
    int solve(int l,int r,int n) {
        FOR(i,1,n+2) sum[i]=sum[i-1]+qwq[i][n];
        modint tmpl,tmpr;
        if(l<=n+2) tmpl=sum[l];
        else tmpl=lagrange(n+2,sum,l);
        if(r<=n+2) tmpr=sum[r];
        else tmpr=lagrange(n+2,sum,r);
        tmpr-=tmpl;
        return tmpr.x;
    }
    void main(){
        init(n+2);
        FOR(i,1,n) c[++tot]=a[i];c[++tot]=1;
        sort(c+1,c+1+tot);tot=unique(c+1,c+1+tot)-c-1;
        modint ans=0;
        FOR(i,1,tot-1) {
            int l=c[i],r=c[i+1];
            modint tmp=1;int cnt=0;
            FOR(j,1,n) {
                if(l>=a[j]) tmp*=a[j];
                else ++cnt;
            }
            tmp*=solve(l-1,r-1,cnt);
            ans+=tmp;
        }
        modint tmp=1;
        FOR(i,1,n)tmp*=a[i];tmp^=(mod-2);
        ans*=tmp;
        cout<<(Mx-ans.x+mod)%mod<<endl;
    }
}
//-------------------------------------------//
bool Med;
signed main() {
#ifdef LOCAL
    freopen("1.in","r",stdin);
#else
    freopen("dice.in","r",stdin);
    freopen("dice.out","w",stdout);
#endif
    rd(n);FOR(i,1,n)rd(a[i]);
    FOR(i,1,n) Mx=max(Mx,a[i]);
    sub3::main();
#ifdef LOCAL    
    fprintf(stderr,"\n%.4lfMB\n",(&Med-&Mbe)/1048576.0);
    fprintf(stderr,"%.4lfs\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
  return 0;
}