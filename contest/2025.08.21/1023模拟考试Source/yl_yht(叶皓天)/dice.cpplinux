/*
Criteria:
1.read the problem carefully; WRITE DOWN SPECIAL CONSTRAINTS when the problem is long;
2.consider special situations/constraints to get observations;
3.think of everything throughout before coding;
4.return to the initial list of notifications after coding.
*/
#include <bits/stdc++.h>
namespace IO {
  #define iL (1 << 20)
  char ibuf[iL], *iS = ibuf + iL, *iT = ibuf + iL;
  #define gc() ((iS == iT) ? (iT = (iS = ibuf) + fread(ibuf, 1, iL, stdin), iS == iT ? EOF : *iS ++) : *iS ++)
  template<class T> inline void read(T &x) {
    x = 0;int f = 0;char ch = gc();
    for (; !isdigit(ch); f |= ch == '-', ch = gc());
    for (; isdigit(ch); x = (x << 1) + (x << 3) + (ch ^ 48), ch = gc());
    x = (f == 1 ? ~ x + 1 : x);
  }
  char Out[iL], *iter = Out;
  #define flush() fwrite(Out, 1, iter - Out, stdout), iter = Out
  template<class T> inline void write(T x, char ch = '\n') {
    T l, c[35];
    if (x < 0) *iter ++ = '-', x = ~ x + 1;
    for (l = 0; !l || x; c[l] = x % 10, l++, x /= 10);
    for (; l; -- l, *iter ++ = c[l] + '0');*iter ++ = ch;
    flush();
  }
}
using namespace IO;
#define N 5005
#define ll long long
#define DEBUG
#define pii pair<int, int>
#define mp make_pair
#define fi first
#define se second
#define MOD 1000000007
using namespace std;
ll n, a[N];
ll qpow(ll a, ll b) { ll r = 1; while (b) { if (b & 1) r = r * a % MOD; a = a * a % MOD, b >>= 1ll; } return r; }
namespace sub1 {
  ll f[N][N], mx;
  void main() {
    for (int i = 1; i <= n; i++) mx = max(mx, a[i]);
    f[0][0] = 1;
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= a[i]; j++) {
        ll t = 0;
        for (int k = 0; k <= j; k++) t = (t + f[i - 1][k]) % MOD;
        f[i][j] = (f[i][j] + t * qpow(a[i], MOD - 2) % MOD) % MOD;
        for (int k = j + 1; k <= mx; k++) f[i][k] = (f[i][k] + f[i - 1][k] * qpow(a[i], MOD - 2) % MOD) % MOD;
      }
      for (int j = a[i] + 1; j <= mx; j++) f[i][j] = f[i - 1][j];
    }
    ll ans = 0; for (int i = 0; i <= mx; i++) ans = (ans + f[n][i] * i % MOD) % MOD;
    write(ans);
  }
}
// namespace sub2 {
//   bool check() { for (int i = 1; i <= n; i++) if (a[i] > 1e6) return false; return true; }
//   ll mx = 0, ans = 0, ina[N];
//   void main() {
//     for (int i = 1; i <= n; i++) mx = max(mx, a[i]), ina[i] = qpow(a[i], MOD - 2);
//     ans = mx;
//     for (int i = 1; i < mx; i++) { ll r = 1;
//       for (int j = 1; j <= n; j++) {
//         if (a[j] >= i) r = (r * i % MOD * ina[j] % MOD);
//       }
//       ans = (ans - r + MOD) % MOD;
//     }
//     write(ans);
//   }
// }
namespace sub2 {
  bool check() { for (int i = 1; i <= n; i++) if (a[i] > 1e6) return false; return true; }
  ll mx = 0, ans = 0, ina[N], sum[N];
  void main() {
    for (int i = 1; i <= n; i++) mx = max(mx, a[i]);
    ans = mx;
    sort(a + 1, a + 1 + n); sum[n + 1] = 1;
    for (int i = n; i >= 1; i--) sum[i] = sum[i + 1] * qpow(a[i], MOD - 2) % MOD; sum[n + 1] = 0;
    for (int i = 1; i < mx; i++) { ll r = 1;
      int p = lower_bound(a + 1, a + 1 + n, i) - a; 
      if (a[n] < i) continue;
      ans = (ans - qpow(i, (n - p + 1)) * sum[p] % MOD + MOD) % MOD;
    }
    write(ans);
  }
}
namespace sub3 {
  bool check() { for (int i = 1; i < n; i++) if (a[i] != a[i + 1]) return false; return true; }
	ll mx = 0, ans = 0, ina[N];
  void main() {
    for (int i = 1; i <= n; i++) mx = max(mx, a[i]), ina[i] = qpow(a[i], MOD - 2);
		for(int i = 1; i <= mx; i++) ans = (ans + i * (qpow(i, n) - qpow(i - 1, n) + MOD) % MOD) % MOD;
		ans = (ans * qpow(qpow(mx, n), MOD - 2)) % MOD;
    write(ans);
		return ;
	}
}
int main() {
// #ifndef ONLINE_JUDGE
  // freopen("test.in", "r", stdin);
  // freopen("test.out", "w", stdout);
// #endif
  freopen("dice.in", "r", stdin);
  freopen("dice.out", "w", stdout);
  read(n); for (int i = 1; i <= n; i++) read(a[i]);
  // if (n <= 500) { sub1::main(); return 0; }
  if (sub2::check()) { sub2::main(); return 0; }
  if (sub3::check()) { sub3::main(); return 0; }
  return 0;
}