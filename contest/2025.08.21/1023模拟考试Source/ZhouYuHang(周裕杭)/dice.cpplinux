#include <algorithm>
#include <iostream>

using LL = long long;

const int MAXN = 5010, mod = 1e9 + 7;

int qpow (int a, int b) {
	int x = 1;
	while (b) {
		if (b & 1) x = (LL)x * a % mod;
		a = (LL)a * a % mod;
		b >>= 1;
	}
	return x;
}

int n, a[MAXN];
int pre[MAXN], suf[MAXN];
int pw[MAXN][MAXN];
int ifac[MAXN];
int f[MAXN];

void solve () {
	for (int i = 1; i <= n + 2; ++i) {
		pw[i][0] = 1;
		for (int j = 1; j <= n + 2; ++j) {
			pw[i][j] = (LL)pw[i][j - 1] * i % mod;
		}
	}
	
	ifac[0] = ifac[1] = 1;
	for (int i = 2; i <= n + 2; ++i) {
		ifac[i] = (LL)(mod - mod / i) * ifac[mod % i] % mod;
	}
	for (int i = 2; i <= n + 2; ++i) ifac[i] = (LL)ifac[i - 1] * ifac[i] % mod;
}

int calc (int k, int n) {
	for (int i = 1; i <= k + 2; ++i) f[i] = (f[i - 1] + pw[i][k]) % mod;
	pre[0] = suf[k + 3] = 1;
	for (int i = 1; i <= k + 2; ++i) pre[i] = (LL)pre[i - 1] * (n - i) % mod;
	for (int i = k + 2; i; --i) suf[i] = (LL)suf[i + 1] * (n - i) % mod;
	int ans = 0;
	for (int i = 1; i <= k + 2; ++i) {
		int X = (LL)pre[i - 1] * suf[i + 1] % mod;
		int Y = (LL)ifac[i - 1] * ifac[k + 2 - i] % mod;
		ans = (ans + (LL)(((k - i) & 1) ? -Y : Y) * X % mod * f[i]) % mod;
	}
	return (ans < 0 ? ans + mod : ans);
}

int main () {
	freopen("dice.in", "r", stdin);
	freopen("dice.out", "w", stdout);

	std::cin >> n;
	for (int i = 1; i <= n; ++i) std::cin >> a[i];
	std::sort(a + 1, a + n + 1);
	
	solve();
	
	int ans = 0, mul = 1;
	for (int i = n; i; --i) {
		mul = (LL)mul * a[i] % mod;
		int cnt = n - i + 1, tmp = qpow(a[i], cnt + 1);
		tmp = (tmp - calc(cnt, a[i] - 1) + calc(cnt, a[i - 1])) % mod;
		tmp = (tmp - (LL)qpow(a[i - 1], cnt) * (a[i - 1] + 1)) % mod;
		ans = (ans + (LL)tmp * qpow(mul, mod - 2)) % mod;
	}
	
	std::cout << (ans < 0 ? ans + mod : ans);
	return 0;
}