#include <iostream>
#include <cstring>
#include <algorithm>

using LL = long long;

const int MAXN = 70, KanKami = 998244353;

int n, m;
LL l[MAXN], r[MAXN];

bool check (int type) {
	if (type == 1) {
		for (int i = 1; i <= n; ++i) if (r[i] ^ ((1ll << m) - 1)) return false;
		return true;
	}
	else {
		for (int i = 1; i <= n; ++i) {
			if (__builtin_popcountll(r[i] + 1) > 1) return false;
		}
		return true;
	}
}

namespace Subtask1 {
	int f[1 << 21], g[1 << 21];
	
	bool check (int x) {
		int tot = 0;
		bool bit[100];
		memset(bit, 0, sizeof bit);
		while (x) {
			bit[tot++] = (x & 1);
			x >>= 1;
		}
		for (int i = 0; i < m; ++i) if (bit[i] ^ bit[m - i - 1]) return false;
		return true;
	}
	
	void solve () {
		f[0] = 1;
		for (int i = 1; i <= n; ++i) {
			memset(g, 0, sizeof g);
			for (int s1 = 0; s1 < (1 << m); ++s1) {
				for (int s2 = l[i]; s2 <= r[i]; ++s2) {
					(g[s1 ^ s2] += f[s1]) %= KanKami;
				}
			}
			memcpy(f, g, sizeof f);
			int ans = 0;
			for (int i = 0; i < (1 << m); ++i) {
				if (check(i)) (ans += f[i]) %= KanKami;
			}
			std::cout << ans << std::endl;
		}
	}
};

namespace Subtask2 {
	int qpow (int a, int b) {
		int x = 1;
		while (b) {
			if (b & 1) x = (LL)x * a % KanKami;
			a = (LL)a * a % KanKami;
			b >>= 1;
		}
		return x;
	}
	void solve () {
		for (int i = 1; i <= n; ++i) {
			std::cout << qpow(2, i * m - m / 2) << std::endl;
		}
	}
};

namespace Subtask3 {
	int f[MAXN][2];
	bool check (LL x) {
		LL h = (x >> ((m + 1) / 2));
		LL t = (x & ((1ll << (m / 2)) - 1));
		int tot = 0;
		bool bit[100];
		memset(bit, 0, sizeof bit);
		while (h) {
			bit[tot++] = (h & 1);
			h >>= 1;
		}
		for (int i = 0; i <= (m - 2) / 4; ++i) std::swap(bit[i], bit[m / 2 - i - 1]);
		for (int i = 0; i < m / 2; ++i) h |= ((LL)bit[i] << i);
		return h <= t;
	}
	int dfs (int k, bool op, LL s) {
		if (~f[k][op]) return f[k][op];
		if (k < m / 2) {
			if (op) {
				if (check(s)) return f[k][op] = 1;
				else return f[k][op] = 0;
			}
			else {
				return f[k][op] = 1;
			}
		}
		int ans = 0;
		if (op) {
			if (s >> k & 1) {
				ans = (dfs(k - 1, true, s) + dfs(k - 1, false, s)) % KanKami;
			}
			else ans = dfs(k - 1, true, s);
		}
		else {
			ans = (dfs(k - 1, false, s) * 2) % KanKami;
		}
		return f[k][op] = ans;
	}
	int calc (LL n) {
		if (n < 0) return 0;
		memset(f, -1, sizeof f);
		return dfs(m - 1, true, n);
	}
	void solve () {
		std::cout << (calc(r[1]) - calc(l[1] - 1) + KanKami) % KanKami << std::endl;
	}
};

namespace Subtask4 {
	int c[MAXN];
	int qpow (int a, int b) {
		int x = 1;
		while (b) {
			if (b & 1) x = (LL)x * a % KanKami;
			a = (LL)a * a % KanKami;
			b >>= 1;
		}
		return x;
	}
	void solve () {
		for (int i = 1; i <= n; ++i) c[i] = __builtin_ctzll(r[i] + 1);
		for (int i = 1; i <= n; ++i) {
			std::sort(c + 1, c + i + 1);
			int sum = 0;
			for (int j = 1; j < i; ++j) sum += c[j];
			if (2 * c[i] >= m) std::cout << qpow(2, sum + (2 * c[i] - m + 1) / 2) << std::endl;
			else std::cout << qpow(2, sum) << std::endl;
		}
	}
};

int main () {
	freopen("far.in", "r", stdin);
	freopen("far.out", "w", stdout);
	
	std::cin >> n >> m;
	for (int i = 1; i <= n; ++i) std::cin >> l[i] >> r[i];
	
	if (m <= 10) {
		Subtask1::solve();
	}
	else if (check(1)) {
		Subtask2::solve();
	}
	else if (n == 1) {
		Subtask3::solve();
	}
	else if (check(2)) {
		Subtask4::solve();
	}
	
	return 0;
}