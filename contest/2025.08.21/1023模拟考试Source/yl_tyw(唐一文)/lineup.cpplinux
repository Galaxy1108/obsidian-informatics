#include <bits/stdc++.h>
#define db double
#define il inline
#define re register
#define ll long long
#define ui unsigned int
#define fi first
#define se second
#define pii pair<int, int>
#define MP(x, y) make_pair(x, y)
#define eb emplace_back
using namespace std;
namespace IO {
  #define iL (1 << 20)
  #define flush() fwrite(Out, 1, iter - Out, stdout); iter = Out
  #define gc() iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, iL, stdin), iS == iT ? EOF : *iS++ : *iS++
  char Out[iL], *iter = Out;
  template<class T> il void write(T x, char LC = '\n') {
    int c[35], l = 0; if(x < 0) {*iter++ = '-'; x = -x;}
    while(!l || x) {c[++l] = x % 10; x /= 10;}
    while(l) *iter++ = c[l--] + '0';
    *iter++ = LC; flush();
  }
  char ibuf[iL], *iS = ibuf + iL, *iT = ibuf + iL;
  template<class T> il void read(T &x) {
    char c = gc(); bool f = 0; x = 0;
    while(!isdigit(c)) {f |= c == '-'; c = gc();}
    while(isdigit(c)) {x = (x << 1) + (x << 3) + (c & 15); c = gc();}
    if(f) x = -x;
  }
  il int read() {
    int x = 0; char c = gc(); bool f = 0;
    while(!isdigit(c)) {f |= c == '-'; c = gc();}
    while(isdigit(c)) {x = (x << 1) + (x << 3) + (c & 15); c = gc();}
    return f ? -x : x;
  }
}
using namespace IO;
#define N 55
#define MOD 1000000007
int n, a[N];
//namespace bruteforce {
//  int b[N], c[N], l[205], r[205]; pii ans = MP(1e9, 1e9);
//  map<vector<int>, pii> f;
//  il bool check(vector<int> q) {
//    for(re int i = 0; i < n; ++i)
//      if(i + 1 < l[a[q[i]]] || i + 1 > r[a[q[i]]]) return 0;
//    return 1;
//  }
//  void dfs(vector<int> q, int m, int s) {
//    if(f.count(q) && f[q] <= MP(m, s)) return ; f[q] = MP(m, s);
//    if(check(q)) {ans = min(ans, MP(m, s)); return ;}
//    for(re int i = 0; i < n; ++i)
//      for(re int j = 0; j < n; ++j)
//        if(i ^ j) {
//          int w = abs(i - j);
//          swap(q[i], q[j]); c[q[i]] += w; c[q[j]] += w;
//          dfs(q, max(m, max(c[q[i]], c[q[j]])), s + w + w);
//          swap(q[i], q[j]); c[q[i]] -= w; c[q[j]] -= w;
//        }
//  }
//  il void MAIN() {
//    for(re int i = 1; i <= n; ++i) b[i] = a[i];
//    sort(b + 1, b + 1 + n);
//    for(re int i = 1; i <= n; ++i) {
//      if(!l[b[i]]) l[b[i]] = i;
//      r[b[i]] = i;
//    }
//    vector<int> q;
//    for(re int i = 1; i <= n; ++i) q.eb(i);
//    dfs(q, 0, 0); write(ans.se);
//    write(ans.fi);
//  }
//}
//namespace sub1 {
//  int b[N], c[N], id[N], rid[N], v[N], mxpos[205];
//  il void MAIN() {
//    for(re int i = 1; i <= n; ++i) b[i] = a[i];
//    sort(b + 1, b + 1 + n);
//    for(re int i = 1; i <= n; ++i) if(!mxpos[b[i]]) mxpos[b[i]] = i;
//    for(re int i = 1; i <= n; ++i) c[i] = mxpos[a[i]]++;
//    for(re int i = 1; i <= n; ++i) b[i] = i;
//    int mx = 1e9, ans = 1e9;
//    do {
//      for(re int i = 1; i <= n; ++i) id[i] = rid[i] = i, v[i] = 0;
//      for(re int i = 1; i <= n; ++i) {
//        int x = b[i], y = id[c[x]], w = abs(rid[x] - c[x]);
//        v[x] += w; v[y] += w; swap(id[rid[x]], id[c[x]]); swap(rid[x], rid[y]);
//      }
//      int MX = 0, sum = 0;
//      for(re int i = 1; i <= n; ++i) MX = max(MX, v[i]), sum += v[i];
//      if(MX < mx) mx = MX; if(MX == mx) ans = min(ans, sum);
//    } while(next_permutation(b + 1, b + 1 + n));
//    write(ans);
//  }
//}
namespace mystery {
  int b[N], c[N], mxpos[205];
  il void MAIN() {
    for(re int i = 1; i <= n; ++i) b[i] = a[i];
    sort(b + 1, b + 1 + n); int ans = 0;
    for(re int i = 1; i <= n; ++i) if(!mxpos[b[i]]) mxpos[b[i]] = i;
    for(re int i = 1; i <= n; ++i) c[i] = mxpos[a[i]]++;
    for(re int i = 1; i <= n; ++i) ans += abs(i - c[i]);
    write(ans);
  }
}
int main() {
  freopen("lineup.in", "r", stdin);
  freopen("lineup.out", "w", stdout);
  read(n);
  for(re int i = 1; i <= n; ++i) read(a[i]);
//  if(n <= 10) {sub1::MAIN(); return 0;}
//  bruteforce::MAIN();
  mystery::MAIN();
  return 0;
}