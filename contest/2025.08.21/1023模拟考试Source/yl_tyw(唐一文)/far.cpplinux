#include <bits/stdc++.h>
#define db double
#define il inline
#define re register
#define ll long long
#define ui unsigned int
#define fi first
#define se second
#define pii pair<int, int>
#define MP(x, y) make_pair(x, y)
#define eb emplace_back
using namespace std;
namespace IO {
  #define iL (1 << 20)
  #define flush() fwrite(Out, 1, iter - Out, stdout); iter = Out
  #define gc() iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, iL, stdin), iS == iT ? EOF : *iS++ : *iS++
  char Out[iL], *iter = Out;
  template<class T> il void write(T x, char LC = '\n') {
    int c[35], l = 0; if(x < 0) {*iter++ = '-'; x = -x;}
    while(!l || x) {c[++l] = x % 10; x /= 10;}
    while(l) *iter++ = c[l--] + '0';
    *iter++ = LC; flush();
  }
  char ibuf[iL], *iS = ibuf + iL, *iT = ibuf + iL;
  template<class T> il void read(T &x) {
    char c = gc(); bool f = 0; x = 0;
    while(!isdigit(c)) {f |= c == '-'; c = gc();}
    while(isdigit(c)) {x = (x << 1) + (x << 3) + (c & 15); c = gc();}
    if(f) x = -x;
  }
  il int read() {
    int x = 0; char c = gc(); bool f = 0;
    while(!isdigit(c)) {f |= c == '-'; c = gc();}
    while(isdigit(c)) {x = (x << 1) + (x << 3) + (c & 15); c = gc();}
    return f ? -x : x;
  }
}
using namespace IO;
#define N 45
#define M 65
#define MOD 998244353
int n, m; ll L[N], R[N];
namespace sub1 {
  int f[2][1 << 20];
  il bool check(int x) {
    for(re int i = 0; i < m; ++i)
      if((x >> i & 1) != (x >> m - i - 1 & 1)) return 0;
    return 1;
  }
  il void MAIN() {
    f[0][0] = 1;
    for(re int i = 1; i <= n; ++i) {
      int now = i & 1, cur = !now;
      memset(f[now], 0, sizeof(f[now]));
      for(re int j = 0; j < 1 << m; ++j)
        if(f[cur][j])
          for(re int k = L[i]; k <= R[i]; ++k)
            (f[now][j ^ k] += f[cur][j]) %= MOD;
      int ans = 0;
      for(re int j = 0; j < 1 << m; ++j)
        if(check(j)) (ans += f[now][j]) %= MOD;
      write(ans);
    }
  }
}
namespace sub2 {
  il void MAIN() {
    int ans = 1;
    for(re int i = 0; i + i < m; ++i) (ans += ans) %= MOD;
    write(ans);
    for(re int i = 1; i < n; ++i) {
      for(re int j = 0; j < m; ++j) (ans += ans) %= MOD;
      write(ans);
    }
  }
}
namespace sub3 {
  ll f[M]; int a[N];
  ll DFS(int up, int down, int lim, int S) {
    if(up < down) return !lim || (lim & !S);
    if(!lim && ~f[up]) return f[up]; ll ans = 0;
    for(re int i = lim ? a[up] : 1; ~i; --i) {
      if(!lim) {ans += DFS(up - 1, down + 1, lim, S); continue;}
      if(i != a[down]) ans += DFS(up - 1, down + 1, lim & (i == a[up]), i > a[down]);
      else ans += DFS(up - 1, down + 1, lim & (i == a[up]), S);
    }
    if(!lim) f[up] = ans; return ans;
  }
  il ll solve(ll x) {
    for(re int i = 1; i <= m; ++i) a[i] = x >> i - 1 & 1;
    return DFS(m, 1, 1, 0);
  }
  il void MAIN() {
    memset(f, -1, sizeof(f));
    write((solve(R[1]) - (L[1] ? solve(L[1] - 1) : 0)) % MOD);
  }
}
int main() {
  freopen("far.in", "r", stdin);
  freopen("far.out", "w", stdout);
  read(n); read(m); bool _sub2 = 1;
  for(re int i = 1; i <= n; ++i) {
    read(L[i]); read(R[i]);
    if(L[i] || R[i] != (1 << m) - 1) _sub2 = 0;
  }
  if(n <= 10 && m <= 10) {sub1::MAIN(); return 0;}
  if(_sub2) {sub2::MAIN(); return 0;}
  if(n == 1) {sub3::MAIN(); return 0;}
  return 0;
}