#include<bits/stdc++.h>
#define db double
#define int ll
#define ll long long
#define ull unsigned long long
#define pb push_back
#define MP make_pair
#define pii pair<int, int>
#define fi first
#define se second
#define ls(k) S[k].lc
#define rs(k) S[k].rc
#define CLK (double)clock()/(double)CLOCKS_PER_SEC*1000.0
using namespace std;
inline int read(){
	register int x=0,f=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(register int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=20005,mod=1e9+7;
int n,m,a[N],cnt,ans,inv;
map<int,int>mp;
int Qpow(int b,int p){
    int res=1ll;
    while(p){
        if(p&1)(res*=b)%=mod;
        (b*=b)%=mod;p>>=1;
    }
    return res;
}
struct Lagrange{
    int vis[N],pri[N],tot,f[N],preL[N],preR[N],sufL[N],sufR[N],fac[N],inv[N],ans;
    void prework(int k){
        fac[0]=inv[0]=fac[1]=inv[1]=1;
        for(int i=2;i<=k+2;i++){
            fac[i]=fac[i-1]*i%mod;
            inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        }
        for(int i=2;i<=k+2;i++)inv[i]=inv[i]*inv[i-1]%mod;
    }
    void init(int n,int k){
        f[1]=1;tot=0;
        for(int i=2;i<=n;i++){
            if(!vis[i]){pri[++tot]=i;f[i]=Qpow(i,k);}
            for(int j=1;j<=tot&&i*pri[j]<=n;j++){
                vis[i*pri[j]]=1;
                f[i*pri[j]]=f[i]*f[pri[j]]%mod;
                if(i%pri[j]==0)break;
            }
        }
        for(int i=2;i<=n;i++)(f[i]+=f[i-1])%=mod;
    }
    int query(int L,int R,int k){
        if(R<=k+2)return f[R]-f[L];
        preL[0]=preR[0]=sufL[k+3]=sufR[k+3]=1;ans=0;
        for(int i=1;i<=k+2;i++)preL[i]=preL[i-1]*(L-i)%mod,preR[i]=preR[i-1]*(R-i)%mod;
        for(int i=k+2;i>=1;i--)sufL[i]=sufL[i+1]*(L-i)%mod,sufR[i]=sufR[i+1]*(R-i)%mod;
        //for(int i=1;i<=k+2;i++)cout<<preL[i]<<' '<<preR[i]<<' '<<sufL[i]<<' '<<sufR[i]<<"\n";
        for(int i=1;i<=k+2;i++){
            int P=(preR[i-1]*sufR[i+1]%mod-preL[i-1]*sufL[i+1]%mod+mod)%mod;
            int Q=inv[i-1]*inv[k+2-i]%mod;
            int coef=(k+2-i)&1?-1:1;
            (ans+=(coef*Q+mod)%mod*P%mod*f[i]%mod)%=mod;
        }
        //cout<<L<<' '<<R<<' '<<ans<<"\n";
        return ans;
    }
}lc;
signed main(){   
	freopen("dice.in","r",stdin);
 	freopen("dice.out","w",stdout);
    n=read();
    for(int i=1;i<=n;i++)a[i]=read(),m=max(m,a[i]),mp[a[i]]++;
    inv=1;for(auto t:mp)(inv*=Qpow(Qpow(t.fi,t.se),mod-2))%=mod,cnt+=t.se;
    mp[m-1]+=mp[m];mp.erase(m);
    lc.prework(n);
    int lst=0;
    for(auto t:mp){
        lc.init(cnt+2,cnt);
        (ans+=lc.query(lst,t.fi,cnt)*inv%mod)%=mod;
        lst=t.fi;cnt-=t.se;(inv*=Qpow(t.fi,t.se))%=mod;
    }
    cout<<(m-ans+mod)%mod;
//  printf("\nTIME:%lf\n",(double)clock()/CLOCKS_PER_SEC);
	return 0;
}

/*
#include<bits/stdc++.h>
#define db double
#define int ll
#define ll long long
#define ull unsigned long long
#define pb push_back
#define MP make_pair
#define pii pair<int, int>
#define fi first
#define se second
#define ls(k) S[k].lc
#define rs(k) S[k].rc
#define CLK (double)clock()/(double)CLOCKS_PER_SEC*1000.0
using namespace std;
inline int read(){
	register int x=0,f=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(register int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=20005,mod=1e9+7;
int n,m,a[N],b[N],cnt[N],ans,raw[N],tot;
int Qpow(int b,int p){
    int res=1ll;
    while(p){
        if(p&1)(res*=b)%=mod;
        (b*=b)%=mod;p>>=1;
    }
    return res;
}
void lsh(){
    sort(raw+1,raw+1+tot);
    tot=unique(raw+1,raw+1+tot)-(raw+1);
    for(int i=1;i<=n;i++)a[i]=lower_bound(raw+1,raw+1+tot,a[i])-raw;
}
struct Lagrange{
    int vis[N],pri[N],tot,f[N],pre[N],suf[N],fac[N],inv[N],ans;
    void init(int n,int k){
        f[1]=1;tot=0;
        for(int i=2;i<=n;i++){
            if(!vis[i]){pri[++tot]=i;f[i]=Qpow(i,k);}
            for(int j=1;j<=tot&&i*pri[j]<=n;j++){
                vis[i*pri[j]]=1;
                f[i*pri[j]]=f[i]*f[pri[j]]%mod;
                if(i%pri[j]==0)break;
            }
        }
        for(int i=2;i<=n;i++)(f[i]+=f[i-1])%=mod;
    }
    int query(int n,int k){
        if(n<=k+2)return f[n];
        pre[0]=suf[k+3]=1;ans=0;
        for(int i=1;i<=k+2;i++)pre[i]=pre[i-1]*(n-i)%mod;
        for(int i=k+2;i>=1;i--)suf[i]=suf[i+1]*(n-i)%mod;
        fac[0]=inv[0]=fac[1]=inv[1]=1;
        for(int i=2;i<=k+2;i++){
            fac[i]=fac[i-1]*i%mod;
            inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        }
        for(int i=2;i<=k+2;i++)inv[i]=inv[i]*inv[i-1]%mod;
        for(int i=1;i<=k+2;i++){
            int P=pre[i-1]*suf[i+1]%mod;
            int Q=inv[i-1]*inv[k+2-i]%mod;
            int coef=(k+2-i)&1?-1:1;
            (ans+=(coef*Q+mod)%mod*P%mod*f[i]%mod)%=mod;
        }
        return ans;
    }
}lc;
signed main(){   
	freopen("dice.in","r",stdin);
 	freopen("dice.out","w",stdout);
    n=read();
    for(int i=1;i<=n;i++)a[i]=read(),m=max(m,a[i]);
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        raw[++tot]=a[i];
        if(i>1)raw[++tot]=a[i]-1;
        if(i<n)raw[++tot]=a[i]+1;
    }
    raw[++tot]=1;lsh();
    //for(int i=1;i<=n;i++)cout<<a[i]<<' ';cout<<"\n";
    for(int i=1;i<=tot;i++)b[i]=1;
    for(int i=1;i<=n;i++)(b[a[i]]*=Qpow(raw[a[i]],mod-2))%=mod,cnt[a[i]]++;
    for(int i=tot-1;i>=1;i--)(b[i]*=b[i+1])%=mod,cnt[i]+=cnt[i+1];
    //for(int i=tot;i>=1;i--)cout<<b[i]<<' ';cout<<"\n";
    for(int i=1;i<tot;i++){
        int sz=0;
        //for(int j=raw[i];j<raw[i+1];j++)(sz+=Qpow(j,cnt[i]))%=mod;
        lc.init(cnt[i]+2,cnt[i]);
        sz=((lc.query(raw[i+1]-1,cnt[i])-lc.query(raw[i]-1,cnt[i]))%mod+mod)%mod;
        int sum=sz*b[i]%mod;
        //cout<<raw[i]<<' '<<raw[i+1]-1<<' '<<sz<<' '<<b[i]<<"\n";
        (ans+=sum)%=mod;
    }
    cout<<((m-ans)%mod+mod)%mod;
  printf("\nTIME:%lf\n",(double)clock()/CLOCKS_PER_SEC);
	return 0;
}




*/


