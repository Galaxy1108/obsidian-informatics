#include<cstdio>
#include<algorithm>
#include<queue>
const int N=30010;
int head[N],to[N<<1],flow[N<<1],cap[N<<1],cost[N<<1],nxt[N<<1],p=1;
inline void add_edge(int u,int v,int w,int c){++p,to[p]=v,cap[p]=w,cost[p]=c,nxt[p]=head[u];head[u]=p;}
inline void add(int u,int v,int w,int c){add_edge(u,v,w,c),add_edge(v,u,0,-c);}
int cur[N],d[N];
bool vis[N];
std::queue<int> Q;
int a[N],b[N],n;
inline bool SPFA(int s,int t)
{
	for(int i=0;i<=2*n+1;++i) d[i]=1e7,cur[i]=head[i],vis[i]=false;
	d[s]=0,vis[s]=true,Q.push(s);
	while(Q.size())
	{
		int u=Q.front();Q.pop(),vis[s]=false;
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(flow[i]<cap[i]&&d[u]+cost[i]<d[v])
			{
				d[v]=d[u]+cost[i];
				if(!vis[v]) Q.push(v),vis[v]=true;
			}
		}
	}
	for(int i=0;i<=2*n+1;++i) vis[i]=false;
	return d[t]<1e7;
}
int Cost;
int DFS(int u,int t,int Flow)
{
	if(u==t||!Flow) return Flow;
	vis[u]=true;
	int res=0;
	for(int &i=cur[u];i&&res<Flow;i=nxt[i])
	{
		int v=to[i];
		if(!vis[v]&&flow[i]<cap[i]&&d[v]==d[u]+cost[i])
		{
			int tmp=DFS(v,t,std::min(Flow-res,cap[i]-flow[i]));
			res+=tmp,flow[i]+=tmp,flow[i^1]-=tmp,Cost+=tmp*cost[i];
		}
	}
	vis[u]=false;
	return res;
}
int main()
{
	freopen("lineup.in","r",stdin);
	freopen("lineup.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),b[i]=a[i];
	std::sort(b+1,b+n+1);
	for(int i=1;i<=n;++i) add(0,i,1,0),add(i+n,2*n+1,1,0);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			if(a[i]==b[j]) add(i,j+n,1,std::abs(i-j));
	while(SPFA(0,2*n+1)) DFS(0,2*n+1,1e9);
	printf("%d",Cost);
	return 0;
}