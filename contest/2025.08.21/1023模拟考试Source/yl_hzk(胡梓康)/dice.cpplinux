#include <bits/stdc++.h>
using namespace std;
const int N = 5e3 + 5,P = 1e9 + 7;
inline int Add(int a,int b) { return (a + b >= P) ? (a + b - P) : (a + b);}
inline int Sub(int a,int b) { return (a < b) ? (a - b + P) : (a - b);}
inline int qpow(int a,int b) { int res = 1;while(b) {if(b&1) res = 1ll * res * a % P;a = 1ll * a * a % P;b >>= 1;} return res;}
int n,a[N],inva[N];
int vals[N],len;
int X[N],Y[N];
int fac[N],ifac[N];
inline void init(int n)
{
	fac[0] = 1;
	for(int i = 1;i <= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[1] = 1;
	for(int i = 2;i <= n;i++) ifac[i] = 1ll * (P - P / i) * ifac[P % i] % P;
	ifac[0] = 1;
	for(int i = 1;i <= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;
}
inline int solve(int n,int x)
{
	int res = 0;
	for(int i = 1;i <= n;i++) if(x == X[i]) return Y[i];
	static int pre[N],suf[N];
	pre[0] = suf[n + 1] = 1;
	for(int i = 1;i <= n;i++)
		pre[i] = 1ll * pre[i - 1] * (x - X[i]) % P;
	for(int i = n;i >= 1;i--)
		suf[i] = 1ll * suf[i + 1] * (x - X[i]) % P;
	for(int i = 1;i <= n;i++)
	{
		int tmp = 1ll * ifac[i - 1] * ifac[n - i] % P;
		if((n - i) & 1) tmp = P - tmp;
		tmp = 1ll * tmp * pre[i - 1] % P * suf[i + 1] % P;
		tmp = 1ll * tmp * Y[i] % P;
		res = Add(res,tmp);
	}
	return res;
}
int nowMul = 1,nowNum = 0;

int Mi[N][N];
inline int Dp(int bound)
{
	int res = 1ll * qpow(bound,nowNum) * nowMul % P;

	--res;
	return P - res;
}
inline int work(int l,int r)
{
	for(int i = 1;i <= n + 2;i++) X[i] = i,Y[i] = Mi[nowNum][i];
	int res = solve(n + 2,r);
	if(l >= 1) res = Sub(res,solve(n + 2,l - 1));
	res = 1ll * res * nowMul % P;
	res = Sub(res,r - l + 1);
	res = P - res;
	return res;
}
int mx;
int main()
{
	freopen("dice.in","r",stdin);
	freopen("dice.out","w",stdout);
	scanf("%d",&n);
	init(n + 3);
	for(int i = 0;i <= n + 2;i++) Mi[0][i] = 1;
	for(int i = 1;i <= n;i++)
	{
		for(int j = 0;j <= n + 2;j++)
			Mi[i][j] = 1ll * Mi[i - 1][j] * j % P;
	}
	for(int i = 0;i <= n;i++)
		for(int j = 1;j <= n + 2;j++)
			Mi[i][j] = Add(Mi[i][j],Mi[i][j - 1]);

	for(int i = 1;i <= n;i++) 
	{
		scanf("%d",&a[i]);
		vals[++len] = a[i];
		mx = max(mx,a[i]);
		inva[i] = qpow(a[i],P - 2);
	
	}
	vals[++len] = -1,vals[++len] = mx + 1;
	sort(vals + 1,vals + len + 1);
	len = unique(vals + 1,vals + len + 1) - vals - 1;
	
	int ans = 0;
	for(int i = 1;i < len;i++)
	{
		nowMul = 1;nowNum = 0;
		for(int j = 1;j <= n;j++)
		{
			if(a[j] >= vals[i + 1])
			nowMul = 1ll * nowMul * inva[j] % P,
			++nowNum;
		} 
		ans = Add(ans,work(vals[i] + 1,vals[i + 1]));
	}

	cout << ans << endl;
	return 0;
}
