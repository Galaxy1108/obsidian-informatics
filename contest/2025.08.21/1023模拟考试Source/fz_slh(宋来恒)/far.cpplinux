#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long
#define fi first
#define sc second
#define mkp make_pair
#define pii pair<int,int>
typedef long long ll;
const int N=45,M=65,oo=1e9+5,mod=998244353;
inline int read() {
    int x=0,flag=0;char ch=getchar();
    while(ch<'0'||ch>'9') {flag|=(ch=='-');ch=getchar();}
    while('0'<=ch&&ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return flag?-x:x;
}
inline int mx(int x,int y) {return x>y?x:y;}
inline int mn(int x,int y) {return x<y?x:y;}
inline void swp(int &x,int &y) {x^=y^=x^=y;}
inline int as(int x) {return x>0?x:-x;}

int n,m,l[N],r[N],ok[N],a[N],val[M],f[2],g[2],Ans,inv[M];
inline int ksm(int a,int b=mod-2) {
    int ans=1;
    while(b) {
        if(b&1) ans=1ll*ans*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return ans;
}
namespace sub1 {
    inline void print() {
        int qt=0;
        for(int i=1;i<=n;++i)
            if(ok[i]==1) a[i]=l[i]-1,++qt;
            else a[i]=r[i];
        int Mid=m/2-1,ans=0;
        for(int i=m-1,S,mul;i>=0;--i) {
            S=0; f[0]=1;f[1]=0; mul=1;
            bool fl=0;
            for(int j=1;j<=n;++j) {
                if((a[j]>>i)&1) {
                    fl=1; S^=1;
                    mul=1ll*(a[j]+1-(1ll<<i))%mod*mul%mod;
                    g[0]=(1ll*(1ll<<i)%mod*f[0]+1ll*(a[j]+1-(1ll<<i))%mod*f[1])%mod;
                    g[1]=(1ll*(1ll<<i)%mod*f[1]+1ll*(a[j]+1-(1ll<<i))%mod*f[0])%mod;
                    f[0]=g[0]; f[1]=g[1];
                } else {
                    mul=1ll*(a[j]+1)%mod*mul%mod;
                    f[0]=1ll*(a[j]+1)%mod*f[0]%mod;
                    f[1]=1ll*(a[j]+1)%mod*f[1]%mod;
                }
            }
            if(fl) {
                if(i<=Mid) {
                    if(S==val[m-1-i]) ans=(ans+1ll*(f[S]-mul+mod)*inv[i])%mod;
                    else ans=(ans+1ll*f[S^1]*inv[i])%mod;
                } else {
                    ans=(ans+1ll*(f[0]+f[1]-mul+mod)%mod*(1ll<<(i-Mid-1))%mod*inv[i])%mod;
                }
            }
            if(i<=Mid&&S!=val[m-1-i]) break;
            val[i]=S;
            for(int j=1;j<=n;++j) a[j]&=((1ll<<i)-1);
            if(i==0) ++ans;
        }
        if(qt&1) Ans=(Ans-ans+mod)%mod;
        else Ans=(Ans+ans)%mod;
    }
    void dfs(int x) {
        if(x>n) {print();return ;}
        if(l[x]) {ok[x]=1;dfs(x+1);}
        ok[x]=2;dfs(x+1);
    }
}
namespace sub2 {
    inline void print() {
        int qt=0;
        for(int i=1;i<=n;++i)
            if(ok[i]==1) a[i]=l[i]-1,++qt;
            else a[i]=r[i];
        int Mid=m/2-1,ans=0;
        for(int i=m-1,S,mul;i>=0;--i) {
            S=0; f[0]=1;f[1]=0; mul=1;
            bool fl=0;
            for(int j=1;j<=n;++j) {
                if((a[j]>>i)&1) {
                    fl=1; S^=1;
                    mul=1ll*(a[j]+1-(1ll<<i))*mul%mod;
                    g[0]=(1ll*(1ll<<i)*f[0]+1ll*(a[j]+1-(1ll<<i))*f[1])%mod;
                    g[1]=(1ll*(1ll<<i)*f[1]+1ll*(a[j]+1-(1ll<<i))*f[0])%mod;
                    f[0]=g[0]; f[1]=g[1];
                } else {
                    mul=1ll*(a[j]+1)*mul%mod;
                    f[0]=1ll*(a[j]+1)*f[0]%mod;
                    f[1]=1ll*(a[j]+1)*f[1]%mod;
                }
            }
            if(fl) {
                if(i<=Mid) {
                    if(S==val[m-1-i]) ans=(ans+1ll*(f[S]-mul+mod)*inv[i])%mod;
                    else ans=(ans+1ll*f[S^1]*inv[i])%mod;
                } else {
                    ans=(ans+1ll*(f[0]+f[1]-mul+mod)*(1ll<<(i-Mid-1))%mod*inv[i])%mod;
                }
            }
            if(i<=Mid&&S!=val[m-1-i]) break;
            val[i]=S;
            for(int j=1;j<=n;++j) a[j]&=((1ll<<i)-1);
            if(i==0) ++ans;
        }
        if(qt&1) Ans=(Ans-ans+mod)%mod;
        else Ans=(Ans+ans)%mod;
    }
    void dfs(int x) {
        if(x>n) {print();return ;}
        if(l[x]) {ok[x]=1;dfs(x+1);}
        ok[x]=2;dfs(x+1);
    }
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("far.in","r",stdin);
    freopen("far.out","w",stdout);
#endif
    n=read();m=read();
    int _n=n;
    for(int i=0;i<m;++i) inv[i]=ksm((1ll<<i)%mod);
    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();
    bool flag=1;
    if(m<=30) {
        for(int i=1;i<=_n;++i) {
            Ans=0;n=i;
            flag&=(l[i]==0&&r[i]==(1ll<<m)-1);
            if(flag) {
                for(int j=1;j<=n;++j) ok[i]=2;
                sub2::print();
            } else sub2::dfs(1);
            printf("%lld\n",Ans);
        }
    } else {
        for(int i=1;i<=_n;++i) {
            Ans=0;n=i;
            flag&=(l[i]==0&&r[i]==(1ll<<m)-1);
            if(flag) {
                for(int j=1;j<=n;++j) ok[i]=2;
                sub1::print();
            } else sub1::dfs(1);
            printf("%lld\n",Ans);
        }
    }
    return 0;
}