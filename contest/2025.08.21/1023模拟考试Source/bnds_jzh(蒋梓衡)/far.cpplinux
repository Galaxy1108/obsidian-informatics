#include <bits/stdc++.h>
using namespace std;

using ll = int64_t;
#define IO(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout),\
	cin.tie(0)->sync_with_stdio(0)
#define F(i, a, b) for (int i = (a), i##end = (b); i <= i##end; i++)
#define FO(i, a, b) F(i, a, int(b) - 1)
#define R(i, a, b) for (int i = (a), i##end = (b); i >= i##end; i--)
#define fi first
#define se second

const int M = 998244353;
int power(int x, int y) {
	int ans = 1;
	for (; y; y >>= 1, x = 1ll * x * x % M) if (y & 1)
		ans = 1ll * ans * x % M;
	return ans;
}

int n, m;
ll l[41], r[41];


vector<pair<ll, ll>> s[41], tmp;

void dfs(ll a, ll b, ll l, ll r) {
	if (a > r || b < l) return;
	if (a <= l && b >= r) return tmp.emplace_back(r - l + 1, l);
	ll m = (l + r) >> 1;
	dfs(a, b, l, m), dfs(a, b, m + 1, r);
}

int f[41][2][2];
ll val[41][2];

ll foo(ll x) {
	for (int i = 0, j = m - 1; i <= j; i++, j--) {
		ll v = x >> j & 1;
		x ^= v << j;
		if (i < j) x ^= v << i;
	}
	return x;
}

struct poly {
	int x, y;
	poly operator + (const poly &f) const {
		return poly{ (x + f.x) % M, (y + f.y) % M };
	}
	poly operator * (const poly &f) const {
		return poly{
			int((1ll * x * f.x + 1ll * y * f.y) % M),
			int((1ll * y * f.x + 1ll * x * f.y) % M)
		};
	}
} F[41][2];

int calc(int i, int n) {
	if (i * 2 + 1 >= m) {
		int pr = 1;
		F(k, 0, n)
			pr = pr * (0ll + f[k][0][0] + f[k][0][1] + f[k][1][0] + f[k][1][1]) % M;
		return pr;
	}
	ll res = 0;
	F(k, 0, n) F(x, 0, 1) {
		val[k][x] &= (1ll << (m - 2 * i)) - 1;
		val[k][x] <<= i;
		val[k][x] = foo(val[k][x]);
		F[k][x] = poly{f[k][x][0], f[k][x][1]};
	}

	if (n <= 4) {
		FO(j, 0, 2 << n) {
			ll sum = 0;
			poly g = {1, 0};
			F(k, 0, n) {
				sum ^= val[k][j >> k & 1];
				g = g * F[k][j >> k & 1];
			}
			if (!sum) res += g.x;
		}
		FO(j, 0, 2 << n) {
			poly g = {0, 1};
			ll sum = 1ll << i;
			F(k, 0, n) {
				sum ^= val[k][j >> k & 1];
				g = g * F[k][j >> k & 1];
			}
			if (!sum) res += g.x;
		}
	} else {
		map<ll, poly> buc;
		int m = n / 2;
		FO(j, 0, 2 << (n - m)) {
			ll sum = 0; poly g = {1, 0};
			F(k, m, n) {
				sum ^= val[k][j >> (k - m) & 1];
				g = g * F[k][j >> (k - m) & 1];
			}
			buc[sum] = buc[sum] + g;
		}
		FO(j, 0, 1 << m) {
			ll sum = 0; poly g = {1, 0};
			FO(k, 0, m) {
				sum ^= val[k][j >> k & 1];
				g = g * F[k][j >> k & 1];
			}
			res += (buc[sum] * g).x;
			res += (buc[sum ^ (1ll << i)] * g).y;
		}
	}
	return res % M;
}
void init(int i, int n, ll len) {
	memset(f, 0, sizeof f);
	F(j, 0, n) {
		map<ll, ll[2]> b;
		for (auto p: s[j]) if (p.fi <= len) {
			ll v = p.se >> i;
			b[v >> 1][v & 1] += p.fi;
		}
		assert(b.size() <= 2);
		int id = 0;
		for (auto p: b) {
			val[j][id] = p.fi << 1;
			f[j][id][0] = p.se[0] % M;
			f[j][id][1] = p.se[1] % M;
			id++;
		}
	}
}

void solve(int n) {
	ll ans = 0;
	F(i, 0, m) {
		ll len = 1ll << i, res = 0;
		init(i, n, len);
		res += calc(i, n);
		init(i, n, len >> 1);
		res += M - calc(i, n);
		res = res % M * power(2, M - 1 - min(i, m / 2)) % M;
		ans += res;
	}
	cout << ans % M << "\n";
}

int main() {
	IO(far);
	cin >> n >> m;
	FO(i, 0, n) {
		cin >> l[i] >> r[i], dfs(l[i], r[i], 0, (1ll << m) - 1), swap(s[i], tmp);
		sort(s[i].begin(), s[i].end());
	}
	FO(i, 0, n) solve(i);
}