#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const LL mod = 1e9 + 7;

LL qpow(LL x, LL k)
{
  LL ans = 1;
  for (; k; k >>= 1) {
    if (k & 1) ans = ans * x % mod;
    x = x * x % mod;
  }
  return ans;
}

const int kN = 1e4;
int n;
LL ans, a[kN], fac[kN];
struct Lagrange
{
  LL y[kN], pre[kN], suf[kN];
  void build(int k) 
  {
    for (int i = 1; i <= k + 2; i++)
      y[i] = (y[i - 1] + qpow(i, k)) % mod;
  }

  LL get(LL k, LL n)
  {
    LL ans = 0;
    pre[0] = suf[n + 3] = 1;
    for (int i = 1; i <= n + 2; i++)
      pre[i] = pre[i - 1] * (k - i) % mod;
    for (int i = n + 2; i >= 1; i--)
      suf[i] = suf[i + 1] * (k - i) % mod;
    for (int i = 1; i <= n + 2; i++) {
      LL o = (n - i + 2) & 1 ? -1 : 1;
      (ans += o * y[i] * pre[i - 1] % mod * suf[i + 1] % mod * fac[i - 1] % mod * fac[n - i + 2] % mod) %= mod;
    }
    return ans;
  }
} Lag;

int main()
{
  freopen("dice.in", "r", stdin);
  freopen("dice.out", "w", stdout);
  scanf("%d", &n);

  fac[0] = 1;
  for (int i = 1; i <= n + 10; i++)
    fac[i] = fac[i - 1] * i % mod;
  fac[n + 10] = qpow(fac[n + 10], mod - 2);
  for (int i = n + 9; i >= 1; i--)
    fac[i] = fac[i + 1] * (i + 1) % mod;

  LL rev = 1;
  for (int i = 1; i <= n; i++)
    scanf("%lld", &a[i]), (rev *= a[i]) %= mod;
  sort(a + 1, a + n + 1, greater<LL>());
  for (int i = 1; i <= n; i++) {
    if (a[i] == a[i + 1]) continue;
    LL mult = 1, cr = qpow(a[i], i + 1), x = a[i + 1];
    for (int j = i + 1; j <= n; j++)
      mult = mult * a[j] % mod;

    Lag.build(i);    // sb
    cr -= Lag.get(a[i] - 1, i);
    (cr += Lag.get(x, i)) %= mod;

    (cr -= qpow(x, i) * (x + 1) % mod) %= mod; 
    (ans += cr * mult) %= mod;
  }
  printf("%lld", (ans * qpow(rev, mod - 2) % mod + mod) % mod);
  return 0;
}
     